<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-technical/programming-language-pragmatics/08" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.9.2">
<title data-rh="true">第八章 | MisakaTang</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://doc.misakatang.cn/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://doc.misakatang.cn/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://doc.misakatang.cn/docs/technical/programming-language-pragmatics/08"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="第八章 | MisakaTang"><meta data-rh="true" name="description" content="Subroutines and Control Abstraction"><meta data-rh="true" property="og:description" content="Subroutines and Control Abstraction"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://doc.misakatang.cn/docs/technical/programming-language-pragmatics/08"><link data-rh="true" rel="alternate" href="https://doc.misakatang.cn/docs/technical/programming-language-pragmatics/08" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://doc.misakatang.cn/docs/technical/programming-language-pragmatics/08" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"第八章","item":"https://doc.misakatang.cn/docs/technical/programming-language-pragmatics/08"}]}</script><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="MisakaTang RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="MisakaTang Atom Feed"><link rel="stylesheet" href="/assets/css/styles.7fbabee1.css">
<script src="/assets/js/runtime~main.dc7a788e.js" defer="defer"></script>
<script src="/assets/js/main.ad4c3d70.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",t||"light"),document.documentElement.setAttribute("data-theme-choice",t||"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="theme-layout-navbar navbar navbar--fixed-top navbarHideable_m1mJ"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Open Source Life</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/technical/programming-language-pragmatics/01">Technical</a><a class="navbar__item navbar__link" href="/docs/daily">Life</a><a class="navbar__item navbar__link" href="/docs/tools/">Tools</a><a class="navbar__item navbar__link" href="/docs/baby/book">Baby</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://misakatang.cn/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">MisakaTang&#x27;s Blog<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><a href="https://github.com/TangMisaka23001" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="切换浅色/暗黑模式（当前为system mode）"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd sidebarWithHideableNavbar_wUlq"><a tabindex="-1" class="sidebarLogo_isFc" href="/"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"><b>Open Source Life</b></a><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" href="/docs/technical/programming-language-pragmatics/01"><span title="Programming Language Pragmatics笔记" class="categoryLinkLabel_W154">Programming Language Pragmatics笔记</span></a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/technical/programming-language-pragmatics/01"><span title="第一章上" class="linkLabel_WmDU">第一章上</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/technical/programming-language-pragmatics/02"><span title="第一章下" class="linkLabel_WmDU">第一章下</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/technical/programming-language-pragmatics/03"><span title="第二章" class="linkLabel_WmDU">第二章</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/technical/programming-language-pragmatics/04"><span title="第三章" class="linkLabel_WmDU">第三章</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/technical/programming-language-pragmatics/05"><span title="第四章" class="linkLabel_WmDU">第四章</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/technical/programming-language-pragmatics/06"><span title="第六章" class="linkLabel_WmDU">第六章</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/technical/programming-language-pragmatics/07"><span title="第七章" class="linkLabel_WmDU">第七章</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/technical/programming-language-pragmatics/08"><span title="第八章" class="linkLabel_WmDU">第八章</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/technical/programming-language-pragmatics/09"><span title="第九章" class="linkLabel_WmDU">第九章</span></a></li></ul></li></ul></nav><button type="button" title="收起侧边栏" aria-label="收起侧边栏" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Programming Language Pragmatics笔记</span></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">第八章</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>第八章</h1></header><h2 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="subroutines-and-control-abstraction">Subroutines and Control Abstraction<a href="#subroutines-and-control-abstraction" class="hash-link" aria-label="Subroutines and Control Abstraction的直接链接" title="Subroutines and Control Abstraction的直接链接" translate="no">​</a></h2>
<p>Subroutines are the principal mechanism for control abstraction in most programming languages.</p>
<ul>
<li class="">A subroutine that returns a value is usually called a <em>function</em>.</li>
<li class="">A subroutine that does not return a value is usually called a <em>procedure</em>.</li>
</ul>
<h3 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="review-of-stack-layout栈内存布局">Review of Stack Layout（栈内存布局）<a href="#review-of-stack-layout栈内存布局" class="hash-link" aria-label="Review of Stack Layout（栈内存布局）的直接链接" title="Review of Stack Layout（栈内存布局）的直接链接" translate="no">​</a></h3>
<p>the <strong>stack pointer</strong> register contains the address of either the last used location at the top of the stack, or the first unused location</p>
<p>The <strong>frame pointer</strong> register contains an address within the frame.</p>
<h3 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="calling-sequences">Calling Sequences<a href="#calling-sequences" class="hash-link" aria-label="Calling Sequences的直接链接" title="Calling Sequences的直接链接" translate="no">​</a></h3>
<p>Maintenance of the subroutine call stack is the responsibility of the calling sequence</p>
<p>Tasks that must be accomplished on the way <strong>into</strong> a subroutine include：</p>
<ul>
<li class="">passing parameters</li>
<li class="">saving the return address</li>
<li class="">changing the program counter</li>
<li class="">changing the stack pointer to allocate space</li>
<li class="">saving registers (including the frame pointer) that contain important values and that may be overwritten by the callee</li>
<li class="">changing the frame pointer to refer to the new frame</li>
<li class="">executing initialization code for any objects in the new frame that require it</li>
</ul>
<p>Tasks that must be accomplished on the way <strong>out</strong> include：</p>
<ul>
<li class="">passing return parameters or function values</li>
<li class="">executing finalization code for any local objects that require it</li>
<li class="">deallocating the stack frame (restoring the stack pointer)</li>
<li class="">restoring other saved registers (including the frame pointer)</li>
<li class="">restoring the program counter</li>
</ul>
<h5 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="saving-and-restoring-registers">Saving and Restoring Registers<a href="#saving-and-restoring-registers" class="hash-link" aria-label="Saving and Restoring Registers的直接链接" title="Saving and Restoring Registers的直接链接" translate="no">​</a></h5>
<p>函数调用最棘手的部分就是保存和恢复寄存器。</p>
<blockquote>
<p>Perhaps the trickiest division-of-labor issue pertains to saving registers.</p>
</blockquote>
<p>A <em>simpler solution</em> is for the caller to save all registers that are in use, or for the callee to save all registers that it will overwrite.</p>
<p>调用约定：</p>
<p>strike something of a compromise: registers not reserved for special purposes are divided into two sets of approximately equal size. One set is the caller’s responsibility, the other is the callee’s responsibility. A callee can assume that there is nothing of value in any of the registers in the caller-saves set; a caller can assume that no callee will destroy the contents of any registers in the callee-saves set.</p>
<h5 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="maintaining-the-static-chain">Maintaining the Static Chain<a href="#maintaining-the-static-chain" class="hash-link" aria-label="Maintaining the Static Chain的直接链接" title="Maintaining the Static Chain的直接链接" translate="no">​</a></h5>
<p>In languages with nested subroutines,at least part of the work required to maintain the static chain must be performed by the caller,rather than the callee,because this work depends on the lexical nesting depth of the caller.</p>
<h5 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="a-typical-calling-sequence">A Typical Calling Sequence<a href="#a-typical-calling-sequence" class="hash-link" aria-label="A Typical Calling Sequence的直接链接" title="A Typical Calling Sequence的直接链接" translate="no">​</a></h5>
<p>The caller：</p>
<ol>
<li class="">saves any caller-saves registers whose values will be needed after the call</li>
<li class="">computes the values of arguments and moves them into the stack or registers</li>
<li class="">computes the static link (if this is a language with nested subroutines), and passes it as an extra, hidden argument</li>
<li class="">uses a special subroutine call instruction to jump to the subroutine, simultaneously passing the return address on the stack or in a register</li>
</ol>
<p>the callee：</p>
<ol>
<li class="">allocates a frame by subtracting an appropriate constant from the sp</li>
<li class="">saves the old frame pointer into the stack, and assigns it an appropriate new value</li>
<li class="">saves any callee-saves registers that may be overwritten by the current routine (including the static link and return address, if they were passed in registers)</li>
</ol>
<p>After the subroutine has completed, the epilogue：</p>
<ol>
<li class="">moves the return value (if any) into a register or a reserved location in the stack</li>
<li class="">restores callee-saves registers if needed</li>
<li class="">restores the fp and the sp</li>
<li class="">jumps back to the return address</li>
</ol>
<p>Finally, the caller：</p>
<ol>
<li class="">moves the return value to wherever it is needed</li>
<li class="">restores caller-saves registers if needed</li>
</ol>
<h4 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="displays">Displays<a href="#displays" class="hash-link" aria-label="Displays的直接链接" title="Displays的直接链接" translate="no">​</a></h4>
<p>One disadvantage of static chains is that access to an object in a scope k levels out requires that the static chain be dereferenced k times.</p>
<p>This number can be reduced to a constant by use of a display.</p>
<blockquote>
<p>为了优化这一过程，可以引入一个叫做 display 的数据结构。display 是一个数组，其中的每个元素都是一个指针，指向不同嵌套层级的活动记录（activation record）。当进入一个函数时，编译器会更新 display 来反映当前的调用环境。具体来说，display[i] 会指向第 i 层嵌套的最近活动记录。</p>
<p>使用 display 可以直接通过数组索引快速定位到任何层级的活动记录，从而让访问外层变量的操作更加高效。这种方法减少了通过多个静态链指针进行跳转的需要，因此可以显著提高程序的运行速度，尤其是在函数嵌套层次较深的情况下。</p>
</blockquote>
<h4 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="case-studies-c-on-the-mips-pascal-on-the-x86">Case Studies: C on the MIPS; Pascal on the x86<a href="#case-studies-c-on-the-mips-pascal-on-the-x86" class="hash-link" aria-label="Case Studies: C on the MIPS; Pascal on the x86的直接链接" title="Case Studies: C on the MIPS; Pascal on the x86的直接链接" translate="no">​</a></h4>
<p>Calling sequences <strong>differ significantly</strong> from machine to machine and even compiler tocompiler</p>
<ul>
<li class="">Compilers for CISC machines tend to pass arguments on the stack; compilers for RISC machines tend to pass arguments in registers.</li>
<li class="">Compilers for CISC machines usually dedicate a register to the frame pointer; compilers for RISC machines often do not.</li>
<li class="">Compilers for CISC machines often rely on special-purpose instructions to implement parts of the calling sequence; available instructions on a RISC machine are typically much simpler.</li>
</ul>
<h4 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="register-windows">Register Windows<a href="#register-windows" class="hash-link" aria-label="Register Windows的直接链接" title="Register Windows的直接链接" translate="no">​</a></h4>
<p>As an alternative to saving and restoring registers on subroutine calls and returns, the original Berkeley RISC machines introduced a <em>hardware mechanism</em> known as <strong>register windows</strong>.</p>
<p>The basic idea is to <em>map</em> the ISA’s limited set of register names onto some subset (window) of a much larger collection of physical registers, and to change the mapping when making subroutine calls.</p>
<h4 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="in-line-expansion">In-Line Expansion<a href="#in-line-expansion" class="hash-link" aria-label="In-Line Expansion的直接链接" title="In-Line Expansion的直接链接" translate="no">​</a></h4>
<p>many language implementations allow certain subroutines to be <em>expanded in-line</em> at the point of call：</p>
<blockquote>
<p>A copy of the “called” routine becomes a part of the “caller”; no actual subroutine calloccurs.</p>
</blockquote>
<p>In-line expansion avoids a variety of overheads,including:</p>
<ul>
<li class="">space allocation,</li>
<li class="">branch delays from the call and return,</li>
<li class="">maintaining the static chain or display,</li>
<li class="">and (often) saving and restoring registers.</li>
</ul>
<p>It also allows the compiler to perform <em>code improvements</em> such as:</p>
<ul>
<li class="">global register allocation</li>
<li class="">instruction scheduling</li>
<li class="">common subexpression elimination across the boundaries between subroutines</li>
</ul>
<h3 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="parameter-passing">Parameter Passing<a href="#parameter-passing" class="hash-link" aria-label="Parameter Passing的直接链接" title="Parameter Passing的直接链接" translate="no">​</a></h3>
<p>Most subroutines are parameterized: they take arguments that control certain aspects of their behavior, or specify the data on which they are to operate.</p>
<p>Parameter names that appear in the declaration of a subroutine are known as <strong>formal parameters</strong>.</p>
<p>Variables and expressions that are passed to a subroutine in a particular call are known as <strong>actual parameters</strong>.</p>
<h4 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="parameter-modes">Parameter Modes<a href="#parameter-modes" class="hash-link" aria-label="Parameter Modes的直接链接" title="Parameter Modes的直接链接" translate="no">​</a></h4>
<p>The two most common parameter-passing modes, called：</p>
<ul>
<li class="">call-by-value</li>
<li class="">call-by-reference</li>
</ul>
<p>call-by-value只要在函数返回时把参数的值写回到调用方，就可以实现和call-by-reference类似的效果</p>
<h5 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="call-by-sharing">Call-by-sharing<a href="#call-by-sharing" class="hash-link" aria-label="Call-by-sharing的直接链接" title="Call-by-sharing的直接链接" translate="no">​</a></h5>
<p>不是值传递。因为：</p>
<blockquote>
<p>if we modify the object to which the formal parameter refers, the program will be able to see those changes through the actual parameter after the subroutine returns</p>
</blockquote>
<p>也不是引用传递，因为：</p>
<blockquote>
<p>although the called routine can change the value of the object to which the actual parameter refers, it cannot change the identity of that object.</p>
</blockquote>
<p>Call-by-sharing is thus commonly implemented the same as call-by-value for objects of immutable type.</p>
<h5 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="the-purpose-of-call-by-reference">The Purpose of Call-by-Reference<a href="#the-purpose-of-call-by-reference" class="hash-link" aria-label="The Purpose of Call-by-Reference的直接链接" title="The Purpose of Call-by-Reference的直接链接" translate="no">​</a></h5>
<ul>
<li class="">需要修改参数</li>
<li class="">传递地址比复制参数节约时间</li>
</ul>
<h4 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="call-by-name">Call-by-Name<a href="#call-by-name" class="hash-link" aria-label="Call-by-Name的直接链接" title="Call-by-Name的直接链接" translate="no">​</a></h4>
<p>Explicit subroutine parameters are not the only language feature that requires a closure to be passed as a parameter.</p>
<p>In general, a language implementation must pass a closure whenever the eventual use of the parameter requires the <strong>restoration of a previous referencing environment</strong>.</p>
<h4 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="special-purpose-parameters">Special-Purpose Parameters<a href="#special-purpose-parameters" class="hash-link" aria-label="Special-Purpose Parameters的直接链接" title="Special-Purpose Parameters的直接链接" translate="no">​</a></h4>
<ul>
<li class="">Conformant Arrays</li>
<li class="">Default (Optional) Parameters</li>
<li class="">Named Parameters: A(name=&#x27;xxx&#x27;, age=24)</li>
<li class="">Variable Numbers of Arguments: fun(string...)</li>
</ul>
<h3 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="generic-subroutines-and-modules">Generic Subroutines and Modules<a href="#generic-subroutines-and-modules" class="hash-link" aria-label="Generic Subroutines and Modules的直接链接" title="Generic Subroutines and Modules的直接链接" translate="no">​</a></h3>
<p>需要泛型的原因：</p>
<blockquote>
<p>In a language like Pascal or Fortran, this static declaration of item type means that the programmer must create separate <strong>copies</strong> of enqueue and dequeue <strong>for every type of item</strong>, even though the entire text of these copies (other than the type names in the procedure headers) is the same.</p>
</blockquote>
<h4 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="implementation-options">Implementation Options<a href="#implementation-options" class="hash-link" aria-label="Implementation Options的直接链接" title="Implementation Options的直接链接" translate="no">​</a></h4>
<p>Generics can be implemented several ways.</p>
<ul>
<li class="">the compiler creates a <strong>separate copy</strong> of the code for every instance</li>
<li class="">guarantees that all instances of a given generic will <strong>share the same code</strong> at run time.</li>
</ul>
<h4 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="generic-parameter-constraints泛型约束">Generic Parameter Constraints（泛型约束）<a href="#generic-parameter-constraints泛型约束" class="hash-link" aria-label="Generic Parameter Constraints（泛型约束）的直接链接" title="Generic Parameter Constraints（泛型约束）的直接链接" translate="no">​</a></h4>
<p>避免使用隐式泛型参数:</p>
<blockquote>
<p>To avoid surprises, it is best to avoid implicit use of the operations of a generic parameter type.</p>
</blockquote>
<h3 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="exception-handling">Exception Handling<a href="#exception-handling" class="hash-link" aria-label="Exception Handling的直接链接" title="Exception Handling的直接链接" translate="no">​</a></h3>
<p>exception handling generally requires the language implementation to “unwind” the subroutine call stack.</p>
<p>try catch语法：</p>
<blockquote>
<p>all provide exception-handling facilities in which handlers are lexically bound to blocks of code, and in which the execution of the handler replaces the yet-to-be-completed portion of the block.</p>
</blockquote>
<p>In practice, exception handlers tend to perform three kinds of operations:</p>
<ul>
<li class="">First, ideally, a handler will compensate for the exception in a way that allows the program to recover and continue execution.</li>
<li class="">Second, when an exception occurs in a given block of code but cannot be handled locally, it is often important to declare a local handler that cleans up any resources allocated in the local block, and then “reraises”the exception, so that it will continue to propagate back to a handler that can (hopefully) recover.</li>
<li class="">Third, if recovery is not possible, a handler can at least print a helpful error message before the program terminates.</li>
</ul>
<h4 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="defining-exceptions">Defining Exceptions<a href="#defining-exceptions" class="hash-link" aria-label="Defining Exceptions的直接链接" title="Defining Exceptions的直接链接" translate="no">​</a></h4>
<p>In many languages, dynamic semantic errors automatically result in exceptions, which the program can then catch. The programmer can also define additional, application-specific exceptions.</p>
<p>Most languages use a throw or raise statement,embedded in an if statement, to raise an exception at run time.</p>
<p>已知和未知异常：</p>
<p>If a subroutine raises an exception but does not catch it internally, it may “return” in an unexpected way.</p>
<p>include in each subroutine header a list of the exceptions that may propagate out of the routine.</p>
<p><em>Unchecked exceptions</em> are typically run-time errors that most programs will want to be fatal</p>
<h4 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="exception-propagation异常传播">Exception Propagation（异常传播）<a href="#exception-propagation异常传播" class="hash-link" aria-label="Exception Propagation（异常传播）的直接链接" title="Exception Propagation（异常传播）的直接链接" translate="no">​</a></h4>
<p>When an exception arises, the handlers are examined in order; control is transferred to the first one that matches the exception.</p>
<h4 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="implementation-of-exceptions">Implementation of Exceptions<a href="#implementation-of-exceptions" class="hash-link" aria-label="Implementation of Exceptions的直接链接" title="Implementation of Exceptions的直接链接" translate="no">​</a></h4>
<p>The most obvious implementation for exceptions maintains a linked-list stack of handlers. When control enters a protected block, the handler for that block is added to the head of the list.</p>
<h3 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="coroutines">Coroutines<a href="#coroutines" class="hash-link" aria-label="Coroutines的直接链接" title="Coroutines的直接链接" translate="no">​</a></h3>
<p>vs continuation：</p>
<blockquote>
<p>a <em>continuation</em> is a constant—it does not change once created—while a <em>coroutine</em> changes every time it runs.</p>
</blockquote>
<p>coroutines are execution contexts that exist concurrently, but that execute one at a time, and that transfer control to each other explicitly, by name. Coroutines can be used to implement iterators and threads.</p>
<h3 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="events">Events<a href="#events" class="hash-link" aria-label="Events的直接链接" title="Events的直接链接" translate="no">​</a></h3>
<p>An event is something to which a running program (a process) needs to respond, but which occurs outside the program, at an unpredictable time.</p>
<p>事件和回调：</p>
<p>Instead, the programmer usually wants a handler—a special subroutine—to be invoked when a given event occurs. Handlers are sometimes known as callback functions,because the run-time system calls back into the main program instead of being called from it.</p>
<h3 class="anchor anchorTargetHideOnScrollNavbar_vjPI" id="summary-and-concluding-remarks">Summary and Concluding Remarks<a href="#summary-and-concluding-remarks" class="hash-link" aria-label="Summary and Concluding Remarks的直接链接" title="Summary and Concluding Remarks的直接链接" translate="no">​</a></h3>
<p>这一章主要关注了控制抽象的主题，特别是子程序。子程序允许程序员将代码封装在一个狭窄的接口后面，然后可以不考虑其实现方式进行使用。控制抽象对于任何大型软件系统的设计和维护都至关重要。从审美的角度来看，像Lisp和Smalltalk这样的语言中，内置和用户定义的控制结构使用相同的语法，这使得控制抽象特别有效。</p>
<p>我们在8.1节开始研究子程序，首先回顾了子程序调用堆栈的管理。然后我们考虑了用于维护堆栈的调用序列，PLP CD的额外部分专门讨论了展示；MIPSpro C编译器和GNU x86 Pascal编译器（gpc）的案例研究；以及SPARC的寄存器窗口。在简要考虑内联扩展之后，我们在8.3节转向了参数的主题。我们首先考虑了参数传递模式，所有这些模式都是通过传递值、引用或闭包来实现的。我们注意到，语义清晰和实现速度的目标有时会有冲突：通常通过引用传递大参数最有效，但是由此产生的别名可能会导致程序错误。在8.3.3节，我们考虑了特殊的参数传递机制，包括一致的数组、默认（可选）参数、命名参数和可变长度的参数列表。我们注意到，默认和命名参数提供了一种对动态范围的有吸引力的替代方案。在8.4节，我们考虑了泛型子程序和模块的设计和实现。泛型允许在编译时将控制抽象参数化，以参数的类型而不仅仅是它们的值为基础。</p>
<p>在最后的三个主要部分，我们考虑了异常处理机制，这些机制允许程序以良好的结构方式从嵌套的子程序调用序列中“解开”；协程，它  允许程序维护（并在两个或更多执行上下文之间切换）；以及事件，它允许程序响应异步外部活动。在PLP CD上，我们解释了协程如何用于离散事件模拟。我们还注意到，它们可以用来实现迭代器，但在这里存在更简单的替代方案。在第12章，我们将基于协程来实现线程，这些线程并行运行（或看起来并行运行）。</p>
<p>在几个情况下，我们可以看出关于语言应该提供哪些类型的控制抽象的观点正在形成共识。像Fortran和Algol 60这样的语言的有限参数传递模式已被更广泛或灵活的选项取代。Ada和C++等语言中，标准的位置记号法已被默认参数和命名参数所增强。较少结构化的错误处理机制，如标签参数、非局部goto和动态绑定处理器，已被结构化的异常处理器取代，这些异常处理器在子程序内部进行词法范围处理，并且在常见（无异常）情况下可以零成本实现。传统的信号处理机制中的自发子程序调用已被专用线程中的回调取代。在许多情况下，实现这些新特性需要编译器和运行时系统变得更复杂。偶尔，如call-by-name参数、标签参数或非局部goto的情况，语义上令人困惑的特性也难以实现，放弃它们使编译器变得更简单。在其他情况下，一些有用但难以实现的语言特性仍然在一些语言中出现，但在其他语言中则不出现。这一类别的例子包括一等子程序、协程、迭代器、续延和具有无限范围的局部对象。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-tags-row"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/docs/tags/编译器">编译器</a></li><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/docs/tags/programming-language-pragmatics">Programming Language Pragmatics</a></li></ul></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/technical/programming-language-pragmatics/07"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">第七章</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/technical/programming-language-pragmatics/09"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">第九章</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#subroutines-and-control-abstraction" class="table-of-contents__link toc-highlight">Subroutines and Control Abstraction</a><ul><li><a href="#review-of-stack-layout栈内存布局" class="table-of-contents__link toc-highlight">Review of Stack Layout（栈内存布局）</a></li><li><a href="#calling-sequences" class="table-of-contents__link toc-highlight">Calling Sequences</a><ul><li><a href="#displays" class="table-of-contents__link toc-highlight">Displays</a></li><li><a href="#case-studies-c-on-the-mips-pascal-on-the-x86" class="table-of-contents__link toc-highlight">Case Studies: C on the MIPS; Pascal on the x86</a></li><li><a href="#register-windows" class="table-of-contents__link toc-highlight">Register Windows</a></li><li><a href="#in-line-expansion" class="table-of-contents__link toc-highlight">In-Line Expansion</a></li></ul></li><li><a href="#parameter-passing" class="table-of-contents__link toc-highlight">Parameter Passing</a><ul><li><a href="#parameter-modes" class="table-of-contents__link toc-highlight">Parameter Modes</a></li><li><a href="#call-by-name" class="table-of-contents__link toc-highlight">Call-by-Name</a></li><li><a href="#special-purpose-parameters" class="table-of-contents__link toc-highlight">Special-Purpose Parameters</a></li></ul></li><li><a href="#generic-subroutines-and-modules" class="table-of-contents__link toc-highlight">Generic Subroutines and Modules</a><ul><li><a href="#implementation-options" class="table-of-contents__link toc-highlight">Implementation Options</a></li><li><a href="#generic-parameter-constraints泛型约束" class="table-of-contents__link toc-highlight">Generic Parameter Constraints（泛型约束）</a></li></ul></li><li><a href="#exception-handling" class="table-of-contents__link toc-highlight">Exception Handling</a><ul><li><a href="#defining-exceptions" class="table-of-contents__link toc-highlight">Defining Exceptions</a></li><li><a href="#exception-propagation异常传播" class="table-of-contents__link toc-highlight">Exception Propagation（异常传播）</a></li><li><a href="#implementation-of-exceptions" class="table-of-contents__link toc-highlight">Implementation of Exceptions</a></li></ul></li><li><a href="#coroutines" class="table-of-contents__link toc-highlight">Coroutines</a></li><li><a href="#events" class="table-of-contents__link toc-highlight">Events</a></li><li><a href="#summary-and-concluding-remarks" class="table-of-contents__link toc-highlight">Summary and Concluding Remarks</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://newzone.top" target="_blank" rel="noopener noreferrer" class="footer__link-item">LearnData 开源笔记<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://wiki-power.com" target="_blank" rel="noopener noreferrer" class="footer__link-item">Power&#x27;s Wiki<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Friendly Link</div><ul class="footer__items clean-list"><li class="footer__item"><a href="http://blog.bbchen.top" target="_blank" rel="noopener noreferrer" class="footer__link-item">BB chen的漂流记<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="http://blog.zhuzhenyuan.cn" target="_blank" rel="noopener noreferrer" class="footer__link-item">Aurthur_的博客<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 MisakaTang, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>