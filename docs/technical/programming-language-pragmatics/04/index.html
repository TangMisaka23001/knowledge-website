<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-technical/programming-language-pragmatics/04" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.0">
<title data-rh="true">第三章 | MisakaTang</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://doc.misakatang.cn/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://doc.misakatang.cn/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://doc.misakatang.cn/docs/technical/programming-language-pragmatics/04"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="第三章 | MisakaTang"><meta data-rh="true" name="description" content="Names, Scopes, and Bindings"><meta data-rh="true" property="og:description" content="Names, Scopes, and Bindings"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://doc.misakatang.cn/docs/technical/programming-language-pragmatics/04"><link data-rh="true" rel="alternate" href="https://doc.misakatang.cn/docs/technical/programming-language-pragmatics/04" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://doc.misakatang.cn/docs/technical/programming-language-pragmatics/04" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="MisakaTang RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="MisakaTang Atom Feed"><link rel="stylesheet" href="/assets/css/styles.0b6ebd38.css">
<script src="/assets/js/runtime~main.a8aacd8b.js" defer="defer"></script>
<script src="/assets/js/main.10f88eaf.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top navbarHideable_m1mJ"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Open Source Life</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/technical">Technical</a><a class="navbar__item navbar__link" href="/docs/life/coffee">Life</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://misakatang.cn/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">MisakaTang&#x27;s Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><a href="https://github.com/TangMisaka23001" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd sidebarWithHideableNavbar_wUlq"><a tabindex="-1" class="sidebarLogo_isFc" href="/"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"><b>Open Source Life</b></a><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/technical">技术笔记</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/docs/category/programming-language-pragmatics">Programming Language Pragmatics</a><button aria-label="折叠侧边栏分类 &#x27;Programming Language Pragmatics&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/technical/programming-language-pragmatics/01">第一章上</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/technical/programming-language-pragmatics/02">第一章下</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/technical/programming-language-pragmatics/03">第二章</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/technical/programming-language-pragmatics/04">第三章</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/technical/programming-language-pragmatics/05">第四章</a></li></ul></li></ul></nav><button type="button" title="收起侧边栏" aria-label="收起侧边栏" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/programming-language-pragmatics"><span itemprop="name">Programming Language Pragmatics</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">第三章</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>第三章</h1></header><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="names-scopes-and-bindings">Names, Scopes, and Bindings<a href="#names-scopes-and-bindings" class="hash-link" aria-label="Names, Scopes, and Bindings的直接链接" title="Names, Scopes, and Bindings的直接链接">​</a></h2>
<p>A name is a mnemonic character string used to represent something else.</p>
<p>Names allow us to refer to variables, constants, operations, types, and so on using symbolic identifiers rather than low-level concepts like addresses.</p>
<p>Subroutines are control abstractions.</p>
<p>Classes are data abstractions.</p>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="the-notion-of-binding-time">The Notion of Binding Time<a href="#the-notion-of-binding-time" class="hash-link" aria-label="The Notion of Binding Time的直接链接" title="The Notion of Binding Time的直接链接">​</a></h3>
<p>the notion of binding time, which refers not only to the binding of a name to the thing it represents, but also in general to the notion of resolving any design decision in a language implementation.</p>
<p>通常，早期绑定时机与更高的效率相关，而后期的绑定时机与更大的灵活性相关。</p>
<p>不同的东西的绑定时机是不一样的：</p>
<ul>
<li>Language design time：控制流结构，基本类型，复杂对象组织方法等语义方面的内容</li>
<li>Language implementation time：基础类型大小，和操作系统交互，堆和栈的组织方式和大小</li>
<li>Program writing time：算法，数据结构，命名</li>
<li>Compile time：高级数据结构和机器码的映射，静态数据的内存布局</li>
<li>Link time：引用其他的模块的绑定关系到链接时才能确定（增量编译）</li>
<li>Load time：程序装载时才能确定实际的地址（虚实地址转换）</li>
<li>Run time：变量值绑定，程序启动时机，模块装载时机，首次“看到”声明的时机，子程序调用时机，代码块进入时机，表达式求值、语句执行时机</li>
</ul>
<p>Compiler-based language implementations tend to be more efficient than interpreter-based implementations because they make earlier decisions.</p>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="object-lifetime-and-storage-management">Object Lifetime and Storage Management<a href="#object-lifetime-and-storage-management" class="hash-link" aria-label="Object Lifetime and Storage Management的直接链接" title="Object Lifetime and Storage Management的直接链接">​</a></h3>
<p>The period of time between the creation and the destruction of a name-to-object binding is called the binding’s lifetime.</p>
<p>生命周期管理不正确肯能会导致“悬挂指针”</p>
<p>对象的生命周期取决于存储分配机制（对象空间）：</p>
<ul>
<li>静态对象（绝对地址）</li>
<li>栈对象（栈上分配，通常在子程序调用）</li>
<li>堆对象（随时分配）</li>
</ul>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="static-allocation">Static Allocation<a href="#static-allocation" class="hash-link" aria-label="Static Allocation的直接链接" title="Static Allocation的直接链接">​</a></h4>
<p>Global variables are the obvious example of static objects, but not the only one.</p>
<p>Numeric and string-valued constant literals are also statically allocated.</p>
<p>Finally, most compilers produce a variety of tables that are used by run-time support routines for debugging, dynamic type checking, garbage collection, exception handling, and other purposes; these are also statically allocated.</p>
<p>Manifest constants can always be allocated statically, even if they are local to a recursive subroutine: multiple instances can share the same location.</p>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="stack-based-allocation">Stack-Based Allocation<a href="#stack-based-allocation" class="hash-link" aria-label="Stack-Based Allocation的直接链接" title="Stack-Based Allocation的直接链接">​</a></h4>
<p>If a language permits recursion, static allocation of local variables is no longer an option.</p>
<p>Fortunately, the natural nesting of subroutine calls makes it easy to allocate space for locals on a stack.</p>
<p>Each instance of a subroutine at run time has its own frame (also called an activation record) on the stack, containing arguments and return values, local variables, temporaries, and bookkeeping information.</p>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="heap-based-allocation">Heap-Based Allocation<a href="#heap-based-allocation" class="hash-link" aria-label="Heap-Based Allocation的直接链接" title="Heap-Based Allocation的直接链接">​</a></h4>
<p>A heap is a region of storage in which subblocks can be allocated and deallocated at arbitrary times.</p>
<p>Heaps are required for the dynamically allocated pieces of linked data structures, and for objects such as fully general character strings, lists, and sets, whose size may change as a result of an assignment statement or other update operation.</p>
<p>The principal concerns are speed and space, and as usual there are tradeoffs between them.</p>
<p>堆内存管理方法：</p>
<ul>
<li>With a <strong>first fit</strong> algorithm we select the first block on the list that is large enough to satisfy the request.</li>
<li>With a <strong>best fit</strong> algorithm we search the entire list to find the smallest block that is large enough to satisfy the request.</li>
</ul>
<p>两者的对比：</p>
<p>Intuitively, one would expect a best fit algorithm to do a better job of reserving large blocks for large requests. At the same time, it has <strong>higher allocation cost</strong> than a first fit algorithm, because it must always search the entire list, and it tends to result in a larger number of very small “left-over” blocks.</p>
<h5 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="内存管理存在的问题">内存管理存在的问题：<a href="#内存管理存在的问题" class="hash-link" aria-label="内存管理存在的问题：的直接链接" title="内存管理存在的问题：的直接链接">​</a></h5>
<p>内存分配效率和堆最小大小有关（多次申请）：</p>
<p>In effect, the heap is divided into “pools,” one for each standard size. The division may be static or dynamic. Two common mechanisms for dynamic pool adjustment are known as the <strong>buddy system</strong> and the <strong>Fibonacci heap</strong>.</p>
<p>内存碎片问题：</p>
<p>The problem with external fragmentation is that the ability of the heap to satisfy requests may degrade over time.</p>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="garbage-collection">Garbage Collection<a href="#garbage-collection" class="hash-link" aria-label="Garbage Collection的直接链接" title="Garbage Collection的直接链接">​</a></h4>
<p>The run-time library for such a language must then provide a garbage collection mechanism to identify and reclaim unreachable objects.</p>
<p>手动 vs 自动：</p>
<ul>
<li>The traditional arguments in favor of explicit deallocation are implementation simplicity and execution speed.</li>
<li>manual deallocation errors are among the most common and costly bugs in real-world programs.</li>
</ul>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="scope-rules">Scope Rules<a href="#scope-rules" class="hash-link" aria-label="Scope Rules的直接链接" title="Scope Rules的直接链接">​</a></h3>
<p>The textual region of the program in which a binding is active is its scope. In most modern languages, the scope of a binding is determined statically, that is, at compile time.</p>
<p>作用域分为：</p>
<ul>
<li>statically scoped: compile time</li>
<li>dynamically scoped: bindings depend on the flow of execution at run time</li>
</ul>
<p>At any given point in a program’s execution, the set of active bindings is called the current <strong>referencing environment</strong>. The set is principally determined by static or dynamic scope rules.</p>
<p>binding rules:</p>
<ul>
<li>deep binding: the choice is made when the reference is first created</li>
<li>shallow binding: the choice is made when the reference is finally used</li>
</ul>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="static-scoping">Static Scoping<a href="#static-scoping" class="hash-link" aria-label="Static Scoping的直接链接" title="Static Scoping的直接链接">​</a></h4>
<p>In a language with static (lexical) scoping, the bindings between names and objects can be determined at compile time by examining the text of the program, without consideration of the flow of control at run time.</p>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="nested-subroutines">Nested Subroutines<a href="#nested-subroutines" class="hash-link" aria-label="Nested Subroutines的直接链接" title="Nested Subroutines的直接链接">​</a></h4>
<p>a name that is introduced in a declaration is known in the scope in which it is declared, and in each internally nested scope, unless it is hidden by another declaration of the same name in one or more nested scopes.</p>
<p>To find the object corresponding to a given use of a name, we look for a declaration with that name in the <strong>current, innermost scope</strong>. If there is one, it defines the active binding for the name. Otherwise, we look for a declaration in the <strong>immediately surrounding scope</strong>.</p>
<p>A name-to-object binding that is hidden by a nested declaration of the same name is said to have a hole in its scope.</p>
<p>作用域解析运算符：</p>
<p>In others, the programmer can access the outer meaning of a name by applying a qualifier or <strong>scope resolution operator</strong>.</p>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="declaration-order">Declaration Order<a href="#declaration-order" class="hash-link" aria-label="Declaration Order的直接链接" title="Declaration Order的直接链接">​</a></h4>
<p>Put another way, can an expression E refer to any name declared in the current scope, or only to names that are declared before E in the scope?</p>
<p>Several early languages, required that all declarations appear at the beginning of their scope.</p>
<p>C++ and Java further relax the rules by dispensing with the define-before-use requirement in many cases. In both languages, members of a class (including those that are not defined until later in the program text) are <strong>visible inside all of the class’s methods</strong>.</p>
<h5 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="declarations-and-definitions">Declarations and Definitions<a href="#declarations-and-definitions" class="hash-link" aria-label="Declarations and Definitions的直接链接" title="Declarations and Definitions的直接链接">​</a></h5>
<p>如何处理两个类互相包含彼此？</p>
<p>Recursive types and subroutines introduce a problem for languages that require names to be declared before they can be used: how can two declarations each appear before the other?</p>
<ul>
<li>A declaration introduces a name and indicates its scope, but may omit certain implementation details.</li>
<li>A definition describes the object in sufficient detail for the compiler to determine its implementation.</li>
</ul>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="modules">Modules<a href="#modules" class="hash-link" aria-label="Modules的直接链接" title="Modules的直接链接">​</a></h4>
<p>模块化和信息隐藏，减少认识负荷：</p>
<p>This modularization of effort depends critically on the notion of <strong>information hiding</strong>, which makes objects and algorithms invisible, whenever possible, to portions of the system that do not need them.</p>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="module-types-and-classes">Module Types and Classes<a href="#module-types-and-classes" class="hash-link" aria-label="Module Types and Classes的直接链接" title="Module Types and Classes的直接链接">​</a></h4>
<p>An alternative solution to the multiple instance problem appeared in Euclid, which treated each module as a type. Given a module type, the programmer could declare an arbitrary number of similar module objects.</p>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="dynamic-scoping">Dynamic Scoping<a href="#dynamic-scoping" class="hash-link" aria-label="Dynamic Scoping的直接链接" title="Dynamic Scoping的直接链接">​</a></h4>
<p>In a language with dynamic scoping, the bindings between names and objects depend on the flow of control at <strong>run time</strong>, and in particular on the order in which subroutines are called.</p>
<p>为什么动态作用域到运行时才能确定？</p>
<p>Because the flow of control cannot in general be predicted in advance, the bindings between names and objects in a language with dynamic scoping cannot in general be determined by a compiler.</p>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="implementing-scope">Implementing Scope<a href="#implementing-scope" class="hash-link" aria-label="Implementing Scope的直接链接" title="Implementing Scope的直接链接">​</a></h3>
<p>To keep track of the names in a statically scoped program, a compiler relies on a data abstraction called a <strong>symbol table</strong>.</p>
<p>In a language with dynamic scoping, an interpreter (or the output of a compiler) must perform operations analogous to symbol table <strong>insert and lookup at run time</strong>.</p>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="the-meaning-of-names-within-a-scope">The Meaning of Names within a Scope<a href="#the-meaning-of-names-within-a-scope" class="hash-link" aria-label="The Meaning of Names within a Scope的直接链接" title="The Meaning of Names within a Scope的直接链接">​</a></h3>
<p>A name that can refer to more than one object at a given point in the program is said to be overloaded. Overloading is in turn related to the more general subject of polymorphism.</p>
<ul>
<li><code>aliases</code>: Two or more names that refer to the same object at the same point in the program are said to be aliases.</li>
<li><code>overloaded</code>: A name that can refer to more than one object at a given point in the program is said to be overloaded</li>
<li>Redefining Built-in Operators</li>
</ul>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="the-binding-of-referencing-environments">The Binding of Referencing Environments<a href="#the-binding-of-referencing-environments" class="hash-link" aria-label="The Binding of Referencing Environments的直接链接" title="The Binding of Referencing Environments的直接链接">​</a></h3>
<p>When should scope rules be applied to such a subroutine: <strong>when</strong> the reference is first created, or <strong>when</strong> the routine is finally called?</p>
<p>动态作用域常使用 shallow binding：</p>
<p>This late binding of the referencing environment of a subroutine that has been passed as a parameter is known as <strong>shallow binding</strong>.</p>
<p>静态作用域常使用 deep binding：</p>
<p>It therefore makes sense to bind the environment at the time the routine is first passed as a parameter, and then restore that environment when the routine is finally called.</p>
<p>This early binding of the referencing environment is known as <strong>deep binding</strong>.</p>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="subroutine-closures">Subroutine Closures<a href="#subroutine-closures" class="hash-link" aria-label="Subroutine Closures的直接链接" title="Subroutine Closures的直接链接">​</a></h4>
<p>Deep binding is implemented by creating an explicit representation of a referencing environment (generally the one in which the subroutine would execute if called at the present time) and bundling it together with a reference to the subroutine. The bundle as a whole is referred to as a <strong>closure</strong>.</p>
<h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="object-closures">Object Closures<a href="#object-closures" class="hash-link" aria-label="Object Closures的直接链接" title="Object Closures的直接链接">​</a></h4>
<p>An object that plays the role of a function and its referencing environment may variously be called an <em>object closure</em>, a function object, or a functor.</p>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="macro-expansion">Macro Expansion<a href="#macro-expansion" class="hash-link" aria-label="Macro Expansion的直接链接" title="Macro Expansion的直接链接">​</a></h3>
<p>Prior to the development of high-level programming languages, assembly language programmers could find themselves writing <strong>highly repetitive code</strong>. To ease the burden, many assemblers provided sophisticated macro expansion facilities.</p>
<p>So-called <strong>hygienic macros(卫生宏)</strong> implicitly encapsulate their arguments, avoiding unexpected interactions with associativity and precedence.</p>
<h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="summary-and-concluding-remarks">Summary and Concluding Remarks<a href="#summary-and-concluding-remarks" class="hash-link" aria-label="Summary and Concluding Remarks的直接链接" title="Summary and Concluding Remarks的直接链接">​</a></h3>
<p>这一章讨论了名称的主题，以及名称与对象的绑定（在广义上）。我们开始从绑定时间的一般讨论——名称与特定对象关联的时间，或更一般地说，任何开放问题在语言或程序设计或实现中与答案关联的时间。我们定义了对象和名称到对象绑定的生命周期的概念，并指出它们不必相同。然后，我们介绍了三种主要的存储分配机制——静态、栈、和堆——用于管理对象的空间。</p>
<p>在3.3节中，我们描述了名称与对象的绑定是如何受作用域规则的约束。在一些语言中，作用域规则是动态的：一个名称的含义是在最近进入的包含声明且尚未退出的作用域中找到的。然而，在大多数现代语言中，作用域规则是静态的，或者说是词法的：一个名称的含义是在最近的包含声明的词法环绕作用域中找到的。我们发现，词法作用域规则在不同语言之间以重要但有时是微妙的方式变化。我们考虑了哪些类型的作用域是允许嵌套的，作用域是开放的还是封闭的，一个名称的作用域是否包括其声明的整个块，以及是否必须在使用名称之前声明它。我们在3.4节探索了作用域规则的实现。</p>
<p>在3.5节中，我们检查了绑定之间关系的几种方式。别名产生于当在给定作用域中两个或更多名称绑定到同一个对象时。重载产生于一个名称绑定到多个对象时。我们注意到，尽管有时可以通过强 制转换或多态性实现类似重载的行为，但底层机制实际上是非常不同的。在3.6节中，我们考虑了何时将引用环境绑定到作为参数传递、从函数返回或存储在变量中的子程序的问题。我们的讨论涉及了闭包和lambda表达式的概念，这两者在后续章节中都会反复出现。在3.7节和3.8节中，我们考虑了宏和分离编译。</p>
<p>词法作用域的一些更复杂的方面说明了对数据抽象的语言支持的发展，这是我们将在第10章回顾的主题。我们首先描述了像Fortran、Algol 60和C这样的语言中的own或静态变量，这些变量允许子程序中的局部变量在一次调用到下一次调用时保持其值。然后我们注意到，简单模块可以被看作是一种使长期存在的对象对一组子程序局部化的方式，这样它们对程序的其他部分来说是不可见的。通过选择性地导出名称，一个模块可以作为一个或多个抽象数据类型的“管理者”。在更高一层的复杂性中，我们注意到有些语言将模块视为类型，允许程序员创建由模块定义的抽象的任意数量的实例。最后，我们注意到面向对象语言通过提供一个继承机制，这个机制允许定义新的抽象（类）作为现有类的扩展或精化，从而扩展了模块作为类型的方法（以及词法作用域的概念）。</p>
<p>在本章考虑的主题中，我们看到了一些有用的特性的例子（递归、静态作用域、前向引用、一级子程序、无限范围），这些特性因为担心实现的复杂性或运行时成本而被某些语言省略。我们还看到了一个特性的例子（模块规范的私有部分），它是为了方便语言的实现而特别引入的，以及另一个（C语言中的独立编译）其设计显然是为了反映特定的实现。在语言设计的几个额外方面（晚绑定与早绑定、静态与动态作用域、对强制转换和转换的支持、对指针和其他别名的容忍），我们看到实现问题起着重要作用。</p>
<p>在类似的脉络中，看似简单的语言规则可能会有出人意料的含义。例如，在3.3.3节中，我们考虑了整个块作用域与名字必须在使用前声明的要求之间的相互作用。就像Fortran的do循环语法和空白规则（2.2.2节）或Pascal的if...then...else语法（2.3.2节），如果选择不当，作用域规则会使程序分析变得困难，这不仅对编译器如此，对人类同样如此。在未来的章节中，我们将看到几个既令人困惑又难以编译的特性示例。当然，语义的实用性和实现的容易程度并不总是一致的。许多容易编译的特性（例如，goto语句）其价值至少是值得怀疑的。我们还将看到几个非常有用且（概念上）简单的特性，比如垃圾收集（8.5.3节）和统一（7.2.4节，C 7.3.2节和12.2.1节），它们的实现却相当复杂。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-tags-row row margin-bottom--sm"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/docs/tags/编译器">编译器</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/docs/tags/programming-language-pragmatics">Programming Language Pragmatics</a></li></ul></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/technical/programming-language-pragmatics/03"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">第二章</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/technical/programming-language-pragmatics/05"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">第四章</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#names-scopes-and-bindings" class="table-of-contents__link toc-highlight">Names, Scopes, and Bindings</a><ul><li><a href="#the-notion-of-binding-time" class="table-of-contents__link toc-highlight">The Notion of Binding Time</a></li><li><a href="#object-lifetime-and-storage-management" class="table-of-contents__link toc-highlight">Object Lifetime and Storage Management</a></li><li><a href="#scope-rules" class="table-of-contents__link toc-highlight">Scope Rules</a></li><li><a href="#implementing-scope" class="table-of-contents__link toc-highlight">Implementing Scope</a></li><li><a href="#the-meaning-of-names-within-a-scope" class="table-of-contents__link toc-highlight">The Meaning of Names within a Scope</a></li><li><a href="#the-binding-of-referencing-environments" class="table-of-contents__link toc-highlight">The Binding of Referencing Environments</a></li><li><a href="#macro-expansion" class="table-of-contents__link toc-highlight">Macro Expansion</a></li><li><a href="#summary-and-concluding-remarks" class="table-of-contents__link toc-highlight">Summary and Concluding Remarks</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/technical">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://newzone.top" target="_blank" rel="noopener noreferrer" class="footer__link-item">LearnData 开源笔记<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://wiki-power.com" target="_blank" rel="noopener noreferrer" class="footer__link-item">Power&#x27;s Wiki<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">Friendly Link</div><ul class="footer__items clean-list"><li class="footer__item"><a href="http://blog.bbchen.top" target="_blank" rel="noopener noreferrer" class="footer__link-item">BB chen的漂流记<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="http://blog.zhuzhenyuan.cn" target="_blank" rel="noopener noreferrer" class="footer__link-item">Aurthur_的博客<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 MisakaTang, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>