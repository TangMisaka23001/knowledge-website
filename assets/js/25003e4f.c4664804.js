"use strict";(self.webpackChunkmy_knowledge_repo=self.webpackChunkmy_knowledge_repo||[]).push([[3113],{5556:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"/2024/crafting-interpreters-notes","metadata":{"permalink":"/blog/2024/crafting-interpreters-notes","source":"@site/blog/2024/crafting-interpreters-notes.md","title":"Crafting Interpreters \u7b14\u8bb0","description":"Scanning","date":"2024-01-25T08:06:02.000Z","tags":[{"label":"\u7f16\u8bd1\u5668","permalink":"/blog/tags/\u7f16\u8bd1\u5668"},{"label":"Crafting Interpreters","permalink":"/blog/tags/crafting-interpreters"}],"readingTime":10.975,"hasTruncateMarker":false,"authors":[],"frontMatter":{"title":"Crafting Interpreters \u7b14\u8bb0","tags":["\u7f16\u8bd1\u5668","Crafting Interpreters"]},"unlisted":false,"nextItem":{"title":"Programming Language Pragmatics \u7b2c\u4e00\u7ae0\u7b14\u8bb0\u4e0a","permalink":"/blog/2024/programming-language-pragmatics-01"}},"content":"## Scanning\\n\u4efb\u4f55\u7f16\u8bd1\u5668\u6216\u89e3\u91ca\u5668\u7684\u7b2c\u4e00\u6b65\u90fd\u662f\u626b\u63cf\u3002\u626b\u63cf\u5668\u5c06\u539f\u59cb\u6e90\u4ee3\u7801\u4f5c\u4e3a\u4e00\u7cfb\u5217\u5b57\u7b26\u8f93\u5165\uff0c\u5e76\u5c06\u5176\u5206\u7ec4\u4e3a\u4e00\u7cfb\u5217\u6211\u4eec\u79f0\u4e4b\u4e3a\u6807\u8bb0\u7684\u5757\u3002\u8fd9\u4e9b\u662f\u6784\u6210\u8bed\u8a00\u8bed\u6cd5\u7684\u6709\u610f\u4e49\u7684\u201c\u5355\u8bcd\u201d\u548c\u201c\u6807\u70b9\u7b26\u53f7\u201d\u3002\\n\\n\u8fd9\u4e00\u9636\u6bb5\u7684\u91cd\u70b9\u662f\u628a\u5b57\u7b26\u6570\u7ec4\u8f6c\u6362\u6210token\u5e8f\u5217\uff0c\u901a\u8fc7\u201c\u53cc\u6307\u9488\u201d\u7684\u65b9\u5f0f\u9010\u6b65\u6d88\u8017\u5b57\u7b26\u3002\\n\\nToken\u7c7b\uff1a\\n```java\\nclass Token {\\n  final TokenType type;\\n  final String lexeme;\\n  final Object literal;\\n  final int line; \\n}\\n```\\n\\nTokenType:\\n```java\\nenum TokenType {\\n  // Single-character tokens.\\n  LEFT_PAREN, RIGHT_PAREN, LEFT_BRACE, RIGHT_BRACE,\\n  COMMA, DOT, MINUS, PLUS, SEMICOLON, SLASH, STAR,\\n\\n  // One or two character tokens.\\n  BANG, BANG_EQUAL,\\n  EQUAL, EQUAL_EQUAL,\\n  GREATER, GREATER_EQUAL,\\n  LESS, LESS_EQUAL,\\n\\n  // Literals.\\n  IDENTIFIER, STRING, NUMBER,\\n\\n  // Keywords.\\n  AND, CLASS, ELSE, FALSE, FUN, FOR, IF, NIL, OR,\\n  PRINT, RETURN, SUPER, THIS, TRUE, VAR, WHILE,\\n\\n  EOF\\n}\\n```\\n\u5904\u7406\u65b9\u5f0f\uff1a\\n```java\\n  private void scanToken() {\\n    char c = advance();\\n    switch (c) {\\n      case \'(\': addToken(LEFT_PAREN); break;      \\n      case \'!\':\\n        addToken(match(\'=\') ? BANG_EQUAL : BANG);\\n        break;\\n    }\\n  }\\n```\\n## Representing Code\\n\u5728\u4e0a\u4e00\u7ae0\u4e2d\uff0c\u6211\u4eec\u5c06\u539f\u59cb\u6e90\u4ee3\u7801\u4f5c\u4e3a\u5b57\u7b26\u4e32\uff0c\u5e76\u5c06\u5176\u8f6c\u6362\u4e3a\u7a0d\u5fae\u66f4\u9ad8\u7ea7\u7684\u8868\u793a\u5f62\u5f0f\uff1a\u4e00\u7cfb\u5217\u6807\u8bb0\u3002\u6211\u4eec\u5c06\u5728\u4e0b\u4e00\u7ae0\u4e2d\u7f16\u5199\u7684\u89e3\u6790\u5668\u5c06\u83b7\u53d6\u8fd9\u4e9b\u6807\u8bb0\uff0c\u5e76\u518d\u6b21\u5c06\u5b83\u4eec\u8f6c\u6362\u4e3a\u66f4\u4e30\u5bcc\u3001\u66f4\u590d\u6742\u7684\u8868\u793a\u5f62\u5f0f\u3002\\n\\n\u5728\u6211\u4eec\u80fd\u591f\u751f\u6210\u8be5\u8868\u793a\u4e4b\u524d\uff0c\u6211\u4eec\u9700\u8981\u5b9a\u4e49\u5b83\u3002\\n\\n\u6211\u4eec\u9700\u8981\u4e00\u628a\u66f4\u5927\u7684\u9524\u5b50\uff0c\u800c\u90a3\u628a\u9524\u5b50\u5c31\u662f\u4e0a\u4e0b\u6587\u65e0\u5173\u6587\u6cd5\uff08CFG\uff09\u3002\u5b83\u662f\u5f62\u5f0f\u6587\u6cd5\u5de5\u5177\u7bb1\u4e2d\u7684\u4e0b\u4e00\u4e2a\u6700\u91cd\u8981\u7684\u5de5\u5177\u3002\u5f62\u5f0f\u6587\u6cd5\u4f7f\u7528\u4e00\u7ec4\u79f0\u4e3a\u201c\u5b57\u6bcd\u8868\u201d\u7684\u539f\u5b50\u7247\u6bb5\u3002\u7136\u540e\u5b83\u5b9a\u4e49\u4e86\u4e00\u7ec4\u901a\u5e38\u662f\u65e0\u9650\u7684\u201c\u5b57\u7b26\u4e32\u201d\uff0c\u8fd9\u4e9b\u5b57\u7b26\u4e32\u201c\u5c5e\u4e8e\u201d\u6587\u6cd5\u3002\u6bcf\u4e2a\u5b57\u7b26\u4e32\u90fd\u662f\u5b57\u6bcd\u8868\u4e2d\u7684\u201c\u5b57\u6bcd\u201d\u5e8f\u5217\u3002\\n\\n\u8bed\u8a00\u8bed\u6cd5\u7684BNF\u8868\u793a\uff1a\\n```\\nexpression     \u2192 literal\\n               | unary\\n               | binary\\n               | grouping ;\\n\\nliteral        \u2192 NUMBER | STRING | \\"true\\" | \\"false\\" | \\"nil\\" ;\\ngrouping       \u2192 \\"(\\" expression \\")\\" ;\\nunary          \u2192 ( \\"-\\" | \\"!\\" ) expression ;\\nbinary         \u2192 expression operator expression ;\\noperator       \u2192 \\"==\\" | \\"!=\\" | \\"<\\" | \\"<=\\" | \\">\\" | \\">=\\"\\n               | \\"+\\"  | \\"-\\"  | \\"*\\" | \\"/\\" ;\\n```\\n\\n## Parsing Expressions\\n\u5728\u89e3\u6790\u4e4b\u524d\u9664\u4e86\u8bed\u6cd5\u89c4\u5219\u8fd8\u9700\u8981\u786e\u5b9a\u5173\u952e\u5b57\u7684\u8fd0\u7b97\u4f18\u5148\u7ea7\u548c\u7ed3\u5408\u6027\uff08\u5de6\u7ed3\u5408\u3001\u53f3\u7ed3\u5408\uff09\u3002\\n\\n\u5c06\u4f18\u5148\u7ea7\u52a0\u5165\u8bed\u6cd5\u89c4\u5219\u4e4b\u540e\u53d8\u6210\u4e0b\u9762\u7684\u5f62\u5f0f\uff1a\\n```\\nexpression     \u2192 equality ;\\nequality       \u2192 comparison ( ( \\"!=\\" | \\"==\\" ) comparison )* ;\\ncomparison     \u2192 term ( ( \\">\\" | \\">=\\" | \\"<\\" | \\"<=\\" ) term )* ;\\nterm           \u2192 factor ( ( \\"-\\" | \\"+\\" ) factor )* ;\\nfactor         \u2192 unary ( ( \\"/\\" | \\"*\\" ) unary )* ;\\nunary          \u2192 ( \\"!\\" | \\"-\\" ) unary\\n               | primary ;\\nprimary        \u2192 NUMBER | STRING | \\"true\\" | \\"false\\" | \\"nil\\"\\n               | \\"(\\" expression \\")\\" ;\\n```\\n\\n### Recursive Descent Parsing\\n\u9012\u5f52\u4e0b\u964d\u6838\u5fc3\u6b65\u9aa4\uff1a\\n```java\\n  private Stmt declaration() {\\n    try {\\n//> Classes match-class\\n      if (match(CLASS)) return classDeclaration();\\n//< Classes match-class\\n//> Functions match-fun\\n      if (match(FUN)) return function(\\"function\\");\\n//< Functions match-fun\\n      if (match(VAR)) return varDeclaration();\\n\\n      return statement();\\n    } catch (ParseError error) {\\n      synchronize();\\n      return null;\\n    }\\n  }\\n```\\n```java\\n  private Stmt classDeclaration() {\\n    Token name = consume(IDENTIFIER, \\"Expect class name.\\");\\n//> Inheritance parse-superclass\\n\\n    Expr.Variable superclass = null;\\n    if (match(LESS)) {\\n      consume(IDENTIFIER, \\"Expect superclass name.\\");\\n      superclass = new Expr.Variable(previous());\\n    }\\n\\n//< Inheritance parse-superclass\\n    consume(LEFT_BRACE, \\"Expect \'{\' before class body.\\");\\n\\n    List<Stmt.Function> methods = new ArrayList<>();\\n    while (!check(RIGHT_BRACE) && !isAtEnd()) {\\n      methods.add(function(\\"method\\"));\\n    }\\n\\n    consume(RIGHT_BRACE, \\"Expect \'}\' after class body.\\");\\n\\n/* Classes parse-class-declaration < Inheritance construct-class-ast\\n    return new Stmt.Class(name, methods);\\n*/\\n//> Inheritance construct-class-ast\\n    return new Stmt.Class(name, superclass, methods);\\n//< Inheritance construct-class-ast\\n  }\\n```\\n\u89e3\u6790\u7684\u7ed3\u679c\u662f\u8fd4\u56de\u4e00\u4e2a\u8bed\u53e5\u5217\u8868\uff1a\\n```\\nList<Stmt> statements = parser.parse();\\n```\\nstmt\u7c7b\u662f\u4e00\u4e2a\u62bd\u8c61\u7c7b\uff0c\u88ab\u5404\u4e2a\u5177\u4f53\u7684\u8bed\u6cd5\u58f0\u660e\u5b9e\u73b0\uff0cclass\u7684\u5b9e\u73b0\u5982\u4e0b\uff1a\\n```java\\n  static class Class extends Stmt {\\n    Class(Token name,\\n          Expr.Variable superclass,\\n          List<Stmt.Function> methods) {\\n      this.name = name;\\n      this.superclass = superclass;\\n      this.methods = methods;\\n    }\\n\\n    @Override\\n    <R> R accept(Visitor<R> visitor) {\\n      return visitor.visitClassStmt(this);\\n    }\\n\\n    final Token name;\\n    final Expr.Variable superclass;\\n    final List<Stmt.Function> methods;\\n  }\\n```\\n\\n## Evaluating Expressions\\n\u8bed\u8a00\u5b9e\u73b0\u6709\u5404\u79cd\u65b9\u5f0f\u8ba9\u8ba1\u7b97\u673a\u6267\u884c\u7528\u6237\u6e90\u4ee3\u7801\u7684\u547d\u4ee4\u3002\u5b83\u4eec\u53ef\u4ee5\u5c06\u5176\u7f16\u8bd1\u6210\u673a\u5668\u7801\uff0c\u7ffb\u8bd1\u6210\u53e6\u4e00\u79cd\u9ad8\u7ea7\u8bed\u8a00\uff0c\u6216\u5c06\u5176\u7b80\u5316\u4e3a\u67d0\u79cd\u5b57\u8282\u7801\u683c\u5f0f\uff0c\u4ee5\u4fbf\u865a\u62df\u673a\u8fd0\u884c\u3002\u7136\u800c\uff0c\u5bf9\u4e8e\u6211\u4eec\u7684\u7b2c\u4e00\u4e2a\u89e3\u91ca\u5668\uff0c\u6211\u4eec\u5c06\u9009\u62e9\u6700\u7b80\u5355\u3001\u6700\u76f4\u63a5\u7684\u8def\u5f84\uff0c\u76f4\u63a5\u6267\u884c\u8bed\u6cd5\u6811\u3002\\n\\n\u4f7f\u7528\u8bbf\u95ee\u8005\u6a21\u5f0f\u6765\u904d\u5386\u4e0a\u9762\u4ea7\u751f\u7684stmt\u5217\u8868\u76f4\u63a5\u8fdb\u884c\u6c42\u503c\uff0c\u4e00\u4e2a\u64cd\u4f5c\u7b26\u904d\u5386\u7684\u4f8b\u5b50\uff1a\\n```java\\n  @Override\\n  public Object visitBinaryExpr(Expr.Binary expr) {\\n    Object left = evaluate(expr.left);\\n    Object right = evaluate(expr.right); \\n\\n    switch (expr.operator.type) {\\n      case MINUS:\\n        return (double)left - (double)right;\\n      case SLASH:\\n        return (double)left / (double)right;\\n      case STAR:\\n        return (double)left * (double)right;\\n    }\\n\\n    // Unreachable.\\n    return null;\\n  }\\n```\\n\\n## Statements and State\\n\u4e3a\u4e86\u652f\u6301\u7ed1\u5b9a\uff0c\u6211\u4eec\u7684\u89e3\u91ca\u5668\u9700\u8981\u5185\u90e8\u72b6\u6001\u3002\u5f53\u4f60\u5728\u7a0b\u5e8f\u5f00\u5934\u5b9a\u4e49\u4e00\u4e2a\u53d8\u91cf\u5e76\u5728\u7ed3\u5c3e\u5904\u4f7f\u7528\u5b83\u65f6\uff0c\u89e3\u91ca\u5668\u5fc5\u987b\u5728\u6b64\u671f\u95f4\u4fdd\u7559\u8be5\u53d8\u91cf\u7684\u503c\u3002\u56e0\u6b64\uff0c\u5728\u672c\u7ae0\u4e2d\uff0c\u6211\u4eec\u5c06\u8d4b\u4e88\u6211\u4eec\u7684\u89e3\u91ca\u5668\u4e00\u4e2a\u4e0d\u4ec5\u80fd\u5904\u7406\uff0c\u8fd8\u80fd\u8bb0\u4f4f\u7684\u5927\u8111\u3002\\n\\n\u72b6\u6001\u548c\u8bed\u53e5\u662f\u76f8\u8f85\u76f8\u6210\u7684\u3002\u7531\u4e8e\u8bed\u53e5\u6839\u636e\u5b9a\u4e49\u4e0d\u4f1a\u8bc4\u4f30\u4e3a\u4e00\u4e2a\u503c\uff0c\u5b83\u4eec\u9700\u8981\u505a\u4e00\u4e9b\u5176\u4ed6\u7684\u4e8b\u60c5\u624d\u80fd\u53d1\u6325\u4f5c\u7528\u3002\u8fd9\u4e2a\u4e8b\u60c5\u88ab\u79f0\u4e3a\u526f\u4f5c\u7528\u3002\u5b83\u53ef\u80fd\u610f\u5473\u7740\u4ea7\u751f\u7528\u6237\u53ef\u89c1\u7684\u8f93\u51fa\u6216\u4fee\u6539\u89e3\u91ca\u5668\u4e2d\u7684\u4e00\u4e9b\u72b6\u6001\uff0c\u4ee5\u4fbf\u4ee5\u540e\u53ef\u4ee5\u68c0\u6d4b\u5230\u3002\u540e\u8005\u4f7f\u5b83\u4eec\u975e\u5e38\u9002\u5408\u5b9a\u4e49\u53d8\u91cf\u6216\u5176\u4ed6\u547d\u540d\u5b9e\u4f53\u3002\\n\\n### Environments\\n\u5c06\u53d8\u91cf\u4e0e\u503c\u5173\u8054\u7684\u7ed1\u5b9a\u9700\u8981\u5b58\u50a8\u5728\u67d0\u4e2a\u5730\u65b9\u3002\u81ea\u4eceLisp\u7684\u53d1\u660e\u8005\u53d1\u660e\u4e86\u62ec\u53f7\u4ee5\u6765\uff0c\u8fd9\u79cd\u6570\u636e\u7ed3\u6784\u5c31\u88ab\u79f0\u4e3a\u73af\u5883\u3002\\n\\n```java\\nclass Environment {\\n  private final Map<String, Object> values = new HashMap<>();\\n}\\n```\\n\\n### Scope\\n\u4f5c\u7528\u57df\u5b9a\u4e49\u4e86\u4e00\u4e2a\u533a\u57df\uff0c\u5176\u4e2d\u4e00\u4e2a\u540d\u79f0\u6620\u5c04\u5230\u67d0\u4e2a\u5b9e\u4f53\u3002\u591a\u4e2a\u4f5c\u7528\u57df\u4f7f\u5f97\u540c\u4e00\u4e2a\u540d\u79f0\u53ef\u4ee5\u5728\u4e0d\u540c\u7684\u4e0a\u4e0b\u6587\u4e2d\u6307\u4ee3\u4e0d\u540c\u7684\u4e8b\u7269\u3002\\n\\n\u8bcd\u6cd5\u4f5c\u7528\u57df\uff08\u6216\u8f83\u5c11\u542c\u5230\u7684\u9759\u6001\u4f5c\u7528\u57df\uff09\u662f\u4e00\u79cd\u7279\u5b9a\u7684\u4f5c\u7528\u57df\u98ce\u683c\uff0c\u7a0b\u5e8f\u6587\u672c\u672c\u8eab\u663e\u793a\u4e86\u4f5c\u7528\u57df\u7684\u5f00\u59cb\u548c\u7ed3\u675f\u4f4d\u7f6e\u3002\\n\\n\u901a\u8fc7\u5bf9\u6c42\u503c\u73af\u5883\u589e\u52a0\u5d4c\u5957\u6765\u5b9e\u73b0\u4f5c\u7528\u57df\u7684\u6548\u679c\uff1a\\n\\n```java\\nclass Environment {\\n  final Environment enclosing; // \u6c42\u503c\u73af\u5883\u5d4c\u5957\\n  private final Map<String, Object> values = new HashMap<>();\\n}\\n```\\n\\n## Control Flow\\n\u76ee\u524d\uff0c\u6211\u4eec\u7684\u89e3\u91ca\u5668\u53ea\u4e0d\u8fc7\u662f\u4e00\u4e2a\u8ba1\u7b97\u5668\u3002Lox\u7a0b\u5e8f\u53ea\u80fd\u5728\u5b8c\u6210\u4e4b\u524d\u505a\u56fa\u5b9a\u6570\u91cf\u7684\u5de5\u4f5c\u3002\u8981\u4f7f\u5176\u8fd0\u884c\u65f6\u95f4\u52a0\u500d\uff0c\u5fc5\u987b\u4f7f\u6e90\u4ee3\u7801\u957f\u5ea6\u52a0\u500d\u3002\u6211\u4eec\u5373\u5c06\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002\u5728\u672c\u7ae0\u4e2d\uff0c\u6211\u4eec\u7684\u89e3\u91ca\u5668\u8fc8\u51fa\u4e86\u5411\u7f16\u7a0b\u8bed\u8a00\u4e3b\u8981\u8054\u8d5b\u8fc8\u8fdb\u7684\u91cd\u8981\u4e00\u6b65\uff1a\u56fe\u7075\u5b8c\u5907\u6027\u3002\\n\\n### IF\\n```java\\n  private Stmt ifStatement() {\\n    consume(LEFT_PAREN, \\"Expect \'(\' after \'if\'.\\");\\n    Expr condition = expression();\\n    consume(RIGHT_PAREN, \\"Expect \')\' after if condition.\\"); \\n\\n    Stmt thenBranch = statement();\\n    Stmt elseBranch = null;\\n    if (match(ELSE)) {\\n      elseBranch = statement();\\n    }\\n\\n    return new Stmt.If(condition, thenBranch, elseBranch);\\n  }\\n```\\n\u5982\u4f55\u5bf9IF\u6c42\u503c\uff1a\\n```java\\n  @Override\\n  public Void visitIfStmt(Stmt.If stmt) {\\n    if (isTruthy(evaluate(stmt.condition))) {\\n      execute(stmt.thenBranch);\\n    } else if (stmt.elseBranch != null) {\\n      execute(stmt.elseBranch);\\n    }\\n    return null;\\n  }\\n```\\n\\n## Functions\\n\u4e00\u65e6\u6211\u4eec\u51c6\u5907\u597d\u88ab\u8c03\u7528\u8005\u548c\u53c2\u6570\uff0c\u5269\u4e0b\u7684\u5c31\u662f\u6267\u884c\u8c03\u7528\u3002\u6211\u4eec\u901a\u8fc7\u5c06\u88ab\u8c03\u7528\u8005\u8f6c\u6362\u4e3aLoxCallable\uff0c\u7136\u540e\u5728\u5176\u4e0a\u8c03\u7528\u4e00\u4e2a call() \u65b9\u6cd5\u6765\u5b9e\u73b0\u8fd9\u4e00\u70b9\u3002\u4efb\u4f55\u53ef\u4ee5\u50cf\u51fd\u6570\u4e00\u6837\u88ab\u8c03\u7528\u7684Lox\u5bf9\u8c61\u7684Java\u8868\u793a\u90fd\u5c06\u5b9e\u73b0\u8fd9\u4e2a\u63a5\u53e3\u3002\u8fd9\u5305\u62ec\u81ea\u5b9a\u4e49\u51fd\u6570\uff0c\u5f53\u7136\u4e5f\u5305\u62ec\u7c7b\u5bf9\u8c61\uff0c\u56e0\u4e3a\u7c7b\u88ab\u201c\u8c03\u7528\u201d\u6765\u6784\u9020\u65b0\u5b9e\u4f8b\u3002\\n\\n```java\\ninterface LoxCallable {\\n  Object call(Interpreter interpreter, List<Object> arguments);\\n}\\n```\\n### Function Objects\\n\u8fd9\u57fa\u672c\u4e0a\u5c31\u662f Stmt.Function \u7c7b\u7684\u4f5c\u7528\u3002\u6211\u4eec\u80fd\u4e0d\u80fd\u76f4\u63a5\u4f7f\u7528\u5b83\uff1f\u51e0\u4e4e\u53ef\u4ee5\uff0c\u4f46\u8fd8\u4e0d\u591f\u3002\u6211\u4eec\u8fd8\u9700\u8981\u4e00\u4e2a\u5b9e\u73b0 LoxCallable \u63a5\u53e3\u7684\u7c7b\uff0c\u8fd9\u6837\u6211\u4eec\u624d\u80fd\u8c03\u7528\u5b83\u3002\u6211\u4eec\u4e0d\u5e0c\u671b\u89e3\u91ca\u5668\u7684\u8fd0\u884c\u65f6\u9636\u6bb5\u6e17\u5165\u524d\u7aef\u7684\u8bed\u6cd5\u7c7b\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u5e0c\u671b Stmt.Function \u672c\u8eab\u5b9e\u73b0\u8fd9\u4e00\u70b9\u3002\u76f8\u53cd\uff0c\u6211\u4eec\u5c06\u5176\u5305\u88c5\u5728\u4e00\u4e2a\u65b0\u7684\u7c7b\u4e2d\u3002\\n\\n```java\\nclass LoxFunction implements LoxCallable {\\n  private final Stmt.Function declaration;\\n  LoxFunction(Stmt.Function declaration) {\\n    this.declaration = declaration;\\n  }\\n}\\n```\\ncall\u7684\u5b9e\u73b0\u5982\u4e0b\uff1a\\n```java\\n  @Override\\n  public Object call(Interpreter interpreter,\\n                     List<Object> arguments) {\\n    Environment environment = new Environment(interpreter.globals);\\n    for (int i = 0; i < declaration.params.size(); i++) {\\n      environment.define(declaration.params.get(i).lexeme,\\n          arguments.get(i));\\n    }\\n\\n    interpreter.executeBlock(declaration.body, environment);\\n    return null;\\n  }\\n```\\n\u6211\u4eec\u5728\u6bcf\u6b21\u8c03\u7528\u65f6\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u73af\u5883\uff0c\u800c\u4e0d\u662f\u5728\u51fd\u6570\u58f0\u660e\u65f6\u3002\u6211\u4eec\u4e4b\u524d\u770b\u5230\u7684\u65b9\u6cd5\u5c31\u662f\u8fd9\u6837\u505a\u7684\u3002\u5728\u8c03\u7528\u5f00\u59cb\u65f6\uff0c\u5b83\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u73af\u5883\u3002\u7136\u540e\u5b83\u4ee5\u6b65\u8c03\u4e00\u81f4\u5730\u904d\u5386\u53c2\u6570\u548c\u53c2\u6570\u5217\u8868\u3002\u5bf9\u4e8e\u6bcf\u4e00\u5bf9\uff0c\u5b83\u90fd\u4f1a\u4f7f\u7528\u53c2\u6570\u7684\u540d\u79f0\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u53d8\u91cf\uff0c\u5e76\u5c06\u5176\u7ed1\u5b9a\u5230\u53c2\u6570\u7684\u503c\u3002\\n\\n## Classes\\n\u7c7b\u7684\u89e3\u6790\u65b9\u5f0f\uff1a\\n```java\\n  private Stmt classDeclaration() {\\n    Token name = consume(IDENTIFIER, \\"Expect class name.\\");\\n    consume(LEFT_BRACE, \\"Expect \'{\' before class body.\\");\\n\\n    List<Stmt.Function> methods = new ArrayList<>();\\n    while (!check(RIGHT_BRACE) && !isAtEnd()) {\\n      methods.add(function(\\"method\\"));\\n    }\\n\\n    consume(RIGHT_BRACE, \\"Expect \'}\' after class body.\\");\\n\\n    return new Stmt.Class(name, methods);\\n  }\\n```\\n\\n### Creating Instances\\n\u4f7f\u7528callable\u6765\u5b9e\u73b0\u7c7b\u7684\u521d\u59cb\u5316\uff1a\\n```java\\nclass LoxClass implements LoxCallable {\\n  final String name;\\n  final LoxClass superclass; // \u7c7b\u7684\u7ee7\u627f\\n  private final Map<String, LoxFunction> methods; // \u7c7b\u65b9\u6cd5\\n\\n  @Override\\n  public Object call(Interpreter interpreter,\\n                     List<Object> arguments) {\\n    LoxInstance instance = new LoxInstance(this);\\n    // \u6784\u9020\u5668\u7ea6\u5b9a\u4e3a\u7279\u6b8a\u7684\u51fd\u6570 \u540d\u4e3ainit\\n    LoxFunction initializer = findMethod(\\"init\\");\\n    if (initializer != null) {\\n      initializer.bind(instance).call(interpreter, arguments);\\n    }\\n}\\n```\\n\u7c7b\u7684\u5b9e\u4f8b\u5305\u542b\uff1a\\n```java\\nclass LoxInstance {\\n\\n  private LoxClass klass;\\n\\n  private final Map<String, Object> fields = new HashMap<>(); // \u7c7b\u5c5e\u6027\\n}\\n```"},{"id":"/2024/programming-language-pragmatics-01","metadata":{"permalink":"/blog/2024/programming-language-pragmatics-01","source":"@site/blog/2024/programming-language-pragmatics-01.md","title":"Programming Language Pragmatics \u7b2c\u4e00\u7ae0\u7b14\u8bb0\u4e0a","description":"The Art of Language Design","date":"2024-01-25T08:06:02.000Z","tags":[{"label":"\u7f16\u8bd1\u5668","permalink":"/blog/tags/\u7f16\u8bd1\u5668"},{"label":"Programming Language Pragmatics","permalink":"/blog/tags/programming-language-pragmatics"}],"readingTime":17.875,"hasTruncateMarker":false,"authors":[],"frontMatter":{"title":"Programming Language Pragmatics \u7b2c\u4e00\u7ae0\u7b14\u8bb0\u4e0a","tags":["\u7f16\u8bd1\u5668","Programming Language Pragmatics"]},"unlisted":false,"prevItem":{"title":"Crafting Interpreters \u7b14\u8bb0","permalink":"/blog/2024/crafting-interpreters-notes"},"nextItem":{"title":"Programming Language Pragmatics \u7b2c\u4e00\u7ae0\u7b14\u8bb0\u4e0b","permalink":"/blog/2024/programming-language-pragmatics-02"}},"content":"## The Art of Language Design\\nToday there are thousands of high-level programming languages, and new ones continue to emerge. Human beings use assembly language only for specialpurpose applications. In a typical undergraduate class, it is not uncommon to find users of scores of different languages. Why are there so many? There are several possible answers:\\n\\n> \u4eca\u5929\u6709\u6210\u5343\u4e0a\u4e07\u79cd\u9ad8\u7ea7\u7f16\u7a0b\u8bed\u8a00\uff0c\u800c\u4e14\u65b0\u7684\u8bed\u8a00\u4e0d\u65ad\u6d8c\u73b0\u3002\u4eba\u7c7b\u53ea\u5728\u7279\u5b9a\u5e94\u7528\u4e2d\u4f7f\u7528\u6c47\u7f16\u8bed\u8a00\u3002\u5728\u5178\u578b\u7684\u672c\u79d1\u8bfe\u7a0b\u4e2d\uff0c\u53d1\u73b0\u4f7f\u7528\u6570\u5341\u79cd\u4e0d\u540c\u8bed\u8a00\u7684\u60c5\u51b5\u5e76\u4e0d\u7f55\u89c1\u3002\u4e3a\u4ec0\u4e48\u4f1a\u6709\u8fd9\u4e48\u591a\u79cd\u8bed\u8a00\uff1f\u8fd9\u6709\u51e0\u4e2a\u53ef\u80fd\u7684\u7b54\u6848\uff1a\\n\\n### Evolution.\\nComputer science is a young discipline; we\u2019re constantly finding better ways to do things. The late 1960s and early 1970s saw a revolution in \u201cstructured programming,\u201d in which the goto-based control flow of languages like Fortran,Cobol,and Basic3 gave way to while loops, case (switch) statements, and similar higher level constructs. In the late 1980s the nested block structure of languages like Algol,Pascal,and Ada began to give way to the object-oriented structure of Smalltalk, C++, Eiffel, and the like.\\n\\n> \u8ba1\u7b97\u673a\u79d1\u5b66\u662f\u4e00\u4e2a\u5e74\u8f7b\u7684\u5b66\u79d1\uff1b\u6211\u4eec\u4e0d\u65ad\u53d1\u73b0\u66f4\u597d\u7684\u505a\u4e8b\u65b9\u5f0f\u300220\u4e16\u7eaa60\u5e74\u4ee3\u672b\u548c70\u5e74\u4ee3\u521d\uff0c\u51fa\u73b0\u4e86\u201c\u7ed3\u6784\u5316\u7f16\u7a0b\u201d\u7684\u9769\u547d\uff0c\u5176\u4e2d\u50cfFortran\u3001Cobol\u548cBasic3\u8fd9\u6837\u57fa\u4e8egoto\u7684\u63a7\u5236\u6d41\u8ba9\u4f4d\u7ed9\u4e86while\u5faa\u73af\u3001case\uff08switch\uff09\u8bed\u53e5\u548c\u7c7b\u4f3c\u7684\u66f4\u9ad8\u7ea7\u6784\u9020\u3002\u5230\u4e8620\u4e16\u7eaa80\u5e74\u4ee3\u672b\uff0c\u50cfAlgol\u3001Pascal\u548cAda\u8fd9\u6837\u7684\u8bed\u8a00\u7684\u5d4c\u5957\u5757\u7ed3\u6784\u5f00\u59cb\u8ba9\u4f4d\u4e8eSmalltalk\u3001C++\u3001Eiffel\u7b49\u9762\u5411\u5bf9\u8c61\u7684\u7ed3\u6784\u3002\\n\\n### Special Purposes.\\nMany languages were designed for a specific problem domain. The various Lisp dialects are good for manipulating symbolic data and complex data structures. Icon and Awk are good for manipulating character strings. C is good for low-level systems programming. Prolog is good for reasoning about logical relationships among data. Each of these languages can be used successfully for a wider range of tasks, but the emphasis is clearly on the specialty.\\n\\n> \u8bb8\u591a\u7f16\u7a0b\u8bed\u8a00\u662f\u4e3a\u7279\u5b9a\u7684\u95ee\u9898\u9886\u57df\u800c\u8bbe\u8ba1\u7684\u3002\u5404\u79cdLisp\u65b9\u8a00\u9002\u7528\u4e8e\u64cd\u7eb5\u7b26\u53f7\u6570\u636e\u548c\u590d\u6742\u6570\u636e\u7ed3\u6784\u3002Icon\u548cAwk\u9002\u7528\u4e8e\u64cd\u7eb5\u5b57\u7b26\u4e32\u3002C\u9002\u7528\u4e8e\u4f4e\u7ea7\u7cfb\u7edf\u7f16\u7a0b\u3002Prolog\u9002\u7528\u4e8e\u63a8\u7406\u6570\u636e\u4e4b\u95f4\u7684\u903b\u8f91\u5173\u7cfb\u3002\u8fd9\u4e9b\u8bed\u8a00\u90fd\u53ef\u4ee5\u6210\u529f\u5730\u7528\u4e8e\u66f4\u5e7f\u6cdb\u7684\u4efb\u52a1\uff0c\u4f46\u91cd\u70b9\u663e\u7136\u5728\u4e8e\u4e13\u4e1a\u9886\u57df\u3002\\n\\n### Personal Preference.\\nDifferent people like different things. Much of the parochialism of programming is simply a matter of taste. Some people love the terseness of C; some hate it. Some people find it natural to think recursively; others prefer iteration. Some people like to work with pointers; others prefer the implicit dereferencing of Lisp, Clu, Java, and ML. The strength and variety of personal preference make it unlikely that anyone will ever develop a universally acceptable programming language.\\n\\n> \u4e0d\u540c\u7684\u4eba\u559c\u6b22\u4e0d\u540c\u7684\u4e1c\u897f\u3002\u7f16\u7a0b\u4e2d\u7684\u5f88\u591a\u504f\u89c1\u53ea\u662f\u54c1\u5473\u4e0a\u7684\u95ee\u9898\u3002\u6709\u4e9b\u4eba\u559c\u6b22C\u7684\u7b80\u6d01\u6027\uff1b\u6709\u4e9b\u4eba\u5219\u8ba8\u538c\u3002\u6709\u4e9b\u4eba\u89c9\u5f97\u9012\u5f52\u601d\u8003\u5f88\u81ea\u7136\uff1b\u800c\u5176\u4ed6\u4eba\u5219\u66f4\u559c\u6b22\u8fed\u4ee3\u3002\u6709\u4e9b\u4eba\u559c\u6b22\u4f7f\u7528\u6307\u9488\uff1b\u5176\u4ed6\u4eba\u5219\u66f4\u559c\u6b22Lisp\u3001Clu\u3001Java\u548cML\u4e2d\u9690\u5f0f\u89e3\u5f15\u7528\u7684\u65b9\u5f0f\u3002\u4e2a\u4eba\u504f\u597d\u7684\u5f3a\u5927\u548c\u591a\u6837\u6027\u4f7f\u5f97\u51e0\u4e4e\u4e0d\u53ef\u80fd\u6709\u4eba\u80fd\u591f\u5f00\u53d1\u51fa\u4e00\u4e2a\u88ab\u666e\u904d\u63a5\u53d7\u7684\u7f16\u7a0b\u8bed\u8a00\u3002\\n\\nOf course, some languages are more successful than others. Of the many that have been designed, only a few dozen are widely used. What makes a language successful? Again there are several answers:\\n\\n> \u5f53\u7136\uff0c\u4e00\u4e9b\u8bed\u8a00\u6bd4\u5176\u4ed6\u8bed\u8a00\u66f4\u6210\u529f\u3002\u5728\u4f17\u591a\u88ab\u8bbe\u8ba1\u51fa\u6765\u7684\u8bed\u8a00\u4e2d\uff0c\u53ea\u6709\u51e0\u5341\u79cd\u88ab\u5e7f\u6cdb\u4f7f\u7528\u3002\u662f\u4ec0\u4e48\u8ba9\u4e00\u79cd\u8bed\u8a00\u6210\u529f\uff1f\u8fd9\u4e2a\u95ee\u9898\u6709\u51e0\u4e2a\u7b54\u6848\uff1a\\n\\n### Expressive Power.\\nOne commonly hears arguments that one language is more \u201cpowerful\u201d than another, though in a formal mathematical sense they are all Turing complete\u2014each can be used, if awkwardly, to implement arbitrary algorithms. Still, language features clearly have a huge impact on the programmer\u2019s ability to write clear, concise, and maintainable code, especially for very large systems. There is no comparison, for example, between early versions of Basic on the one hand, and Common Lisp or Ada on the other. The factors that contribute to expressive power\u2014abstraction facilities in particular\u2014are a major focus of this book.\\n\\n> \u4eba\u4eec\u7ecf\u5e38\u542c\u5230\u6709\u5173\u4e00\u79cd\u8bed\u8a00\u6bd4\u53e6\u4e00\u79cd\u8bed\u8a00\u66f4\u201c\u5f3a\u5927\u201d\u7684\u8bba\u70b9\uff0c\u5c3d\u7ba1\u4ece\u6b63\u5f0f\u7684\u6570\u5b66\u610f\u4e49\u4e0a\u8bb2\uff0c\u5b83\u4eec\u90fd\u662f\u56fe\u7075\u5b8c\u5907\u7684\u2014\u2014\u6bcf\u79cd\u8bed\u8a00\u90fd\u53ef\u4ee5\u88ab\u4f7f\u7528\uff08\u867d\u7136\u6709\u65f6\u4f1a\u5f88\u7b28\u62d9\uff09\u6765\u5b9e\u73b0\u4efb\u610f\u7b97\u6cd5\u3002\u7136\u800c\uff0c\u8bed\u8a00\u7279\u6027\u663e\u7136\u5bf9\u7a0b\u5e8f\u5458\u7f16\u5199\u6e05\u6670\u3001\u7b80\u6d01\u548c\u6613\u7ef4\u62a4\u7684\u4ee3\u7801\u80fd\u529b\u4ea7\u751f\u5de8\u5927\u5f71\u54cd\uff0c\u7279\u522b\u662f\u5bf9\u4e8e\u975e\u5e38\u5e9e\u5927\u7684\u7cfb\u7edf\u3002\u4f8b\u5982\uff0c\u65e9\u671f\u7684Basic\u4e0eCommon Lisp\u6216Ada\u4e4b\u95f4\u662f\u65e0\u6cd5\u6bd4\u8f83\u7684\u3002\u6784\u6210\u8868\u8fbe\u80fd\u529b\u7684\u56e0\u7d20\u2014\u2014\u5c24\u5176\u662f\u62bd\u8c61\u8bbe\u65bd\u2014\u2014\u662f\u672c\u4e66\u7684\u4e3b\u8981\u5173\u6ce8\u70b9\u3002\\n\\n### Ease of Use for the Novice.\\nWhile it is easy to pick on Basic, one cannot deny its success. Part of that success is due to its very low \u201clearning curve.\u201d Logo is popular among elementary-level educators for a similar reason: even a 5-year-old can learn it. Pascal was taught for many years in introductory programming language courses because, at least in comparison to other \u201cserious\u201d languages, it is compact and easy to learn. In recent years Java has come to play a similar role. Though substantially more complex than Pascal, it is much simpler than, say, C++.\\n\\n> \u867d\u7136\u6279\u8bc4Basic\u5f88\u5bb9\u6613\uff0c\u4f46\u4eba\u4eec\u65e0\u6cd5\u5426\u8ba4\u5b83\u7684\u6210\u529f\u3002\u5b83\u7684\u6210\u529f\u90e8\u5206\u5f52\u529f\u4e8e\u5176\u975e\u5e38\u4f4e\u7684\u201c\u5b66\u4e60\u66f2\u7ebf\u201d\u3002\u7c7b\u4f3c\u7684\u539f\u56e0\uff0cLogo\u5728\u5c0f\u5b66\u6559\u80b2\u8005\u4e2d\u5f88\u53d7\u6b22\u8fce\uff1a\u751a\u81f35\u5c81\u7684\u5b69\u5b50\u90fd\u53ef\u4ee5\u5b66\u4f1a\u3002Pascal\u5728\u5f88\u591a\u5e74\u91cc\u88ab\u7528\u6765\u6559\u6388\u5165\u95e8\u7ea7\u7f16\u7a0b\u8bed\u8a00\u8bfe\u7a0b\uff0c\u56e0\u4e3a\u81f3\u5c11\u4e0e\u5176\u4ed6\u201c\u4e25\u8083\u201d\u7684\u8bed\u8a00\u76f8\u6bd4\uff0c\u5b83\u66f4\u4e3a\u7b80\u6d01\u4e14\u6613\u5b66\u3002\u8fd1\u5e74\u6765\uff0cJava\u4e5f\u5f00\u59cb\u626e\u6f14\u7c7b\u4f3c\u7684\u89d2\u8272\u3002\u867d\u7136\u6bd4Pascal\u590d\u6742\u5f97\u591a\uff0c\u4f46\u5b83\u6bd4\u5982C++\u7b49\u8bed\u8a00\u7b80\u5355\u5f97\u591a\u3002\\n\\n### Ease of Implementation.\\nIn addition to its low learning curve, Basic is successful because it could be implemented easily on tiny machines, with limited resources. Forth has a small but dedicated following for similar reasons. Arguably the single most important factor in the success of Pascal was that its designer, Niklaus Wirth, developed a simple, portable implementation of the language, and shipped it free to universities all over the world (see Example 1.15).4 The Java designers took similar steps to make their language available for free to almost anyone who wants it.\\n\\n> \u9664\u4e86\u5176\u4f4e\u5b66\u4e60\u66f2\u7ebf\u4e4b\u5916\uff0cBasic\u4e4b\u6240\u4ee5\u6210\u529f\uff0c\u8fd8\u56e0\u4e3a\u5b83\u53ef\u4ee5\u8f7b\u677e\u5728\u8d44\u6e90\u6709\u9650\u7684\u5c0f\u578b\u8bbe\u5907\u4e0a\u5b9e\u73b0\u3002Forth\u4e5f\u56e0\u7c7b\u4f3c\u7684\u539f\u56e0\u62e5\u6709\u4e00\u5c0f\u90e8\u5206\u5fe0\u5b9e\u7684\u8ffd\u968f\u8005\u3002\u53ef\u4ee5\u8bf4\uff0cPascal\u6210\u529f\u7684\u6700\u91cd\u8981\u56e0\u7d20\u4e4b\u4e00\u662f\u5176\u8bbe\u8ba1\u8005\u5c3c\u53e4\u62c9\u65af\xb7\u6c83\u65af\uff08Niklaus Wirth\uff09\u5f00\u53d1\u4e86\u4e00\u79cd\u7b80\u5355\u3001\u53ef\u79fb\u690d\u7684\u8bed\u8a00\u5b9e\u73b0\uff0c\u5e76\u514d\u8d39\u63d0\u4f9b\u7ed9\u5168\u7403\u5404\u5730\u7684\u5927\u5b66\uff08\u89c1\u793a\u4f8b1.15\uff09\u3002Java\u7684\u8bbe\u8ba1\u8005\u4eec\u4e5f\u91c7\u53d6\u4e86\u7c7b\u4f3c\u7684\u63aa\u65bd\uff0c\u8ba9\u4ed6\u4eec\u7684\u8bed\u8a00\u51e0\u4e4e\u53ef\u4ee5\u514d\u8d39\u63d0\u4f9b\u7ed9\u4efb\u4f55\u60f3\u8981\u4f7f\u7528\u5b83\u7684\u4eba\u3002\\n\\n### Standardization.\\nAlmost every widely used language has an official international standard or (in the case of several scripting languages) a single canonical implementation; and in the latter case the canonical implementation is almost invariably written in a language that has a standard. Standardization\u2014of both the language and a broad set of libraries\u2014is the only truly effective way to ensure the portability of code across platforms. The relatively impoverished standard for Pascal, which is missing several features considered essential by many programmers (separate compilation, strings, static initialization, random-access I/O), is at least partially responsible for the language\u2019s drop from favor in the 1980s. Many of these features were implemented in different ways by different vendors.\\n\\n> \u51e0\u4e4e\u6bcf\u79cd\u5e7f\u6cdb\u4f7f\u7528\u7684\u7f16\u7a0b\u8bed\u8a00\u90fd\u6709\u4e00\u4e2a\u5b98\u65b9\u7684\u56fd\u9645\u6807\u51c6\uff0c\u6216\u8005\uff08\u5728\u4e00\u4e9b\u811a\u672c\u8bed\u8a00\u7684\u60c5\u51b5\u4e0b\uff09\u6709\u4e00\u4e2a\u5355\u4e00\u7684\u89c4\u8303\u5b9e\u73b0\uff1b\u800c\u5728\u540e\u4e00\u79cd\u60c5\u51b5\u4e0b\uff0c\u89c4\u8303\u5b9e\u73b0\u51e0\u4e4e\u603b\u662f\u7528\u4e00\u79cd\u6709\u6807\u51c6\u7684\u8bed\u8a00\u7f16\u5199\u3002\u6807\u51c6\u5316\u2014\u2014\u65e0\u8bba\u662f\u8bed\u8a00\u672c\u8eab\u8fd8\u662f\u4e00\u5957\u5e7f\u6cdb\u7684\u5e93\u2014\u2014\u662f\u786e\u4fdd\u4ee3\u7801\u5728\u5404\u79cd\u5e73\u53f0\u4e0a\u53ef\u79fb\u690d\u7684\u552f\u4e00\u771f\u6b63\u6709\u6548\u7684\u65b9\u6cd5\u3002Pascal\u7684\u6807\u51c6\u76f8\u5bf9\u8f83\u4e3a\u7b80\u964b\uff0c\u7f3a\u5c11\u8bb8\u591a\u88ab\u8bb8\u591a\u7a0b\u5e8f\u5458\u8ba4\u4e3a\u662f\u5fc5\u4e0d\u53ef\u5c11\u7684\u529f\u80fd\uff08\u5982\u72ec\u7acb\u7f16\u8bd1\u3001\u5b57\u7b26\u4e32\u3001\u9759\u6001\u521d\u59cb\u5316\u3001\u968f\u673a\u8bbf\u95eeI/O\uff09\uff0c\u8fd9\u5728\u4e00\u5b9a\u7a0b\u5ea6\u4e0a\u5bfc\u81f4\u4e86\u8be5\u8bed\u8a00\u572820\u4e16\u7eaa80\u5e74\u4ee3\u5931\u5ba0\u3002\u8bb8\u591a\u8fd9\u4e9b\u529f\u80fd\u662f\u7531\u4e0d\u540c\u7684\u4f9b\u5e94\u5546\u4ee5\u4e0d\u540c\u7684\u65b9\u5f0f\u5b9e\u73b0\u7684\u3002\\n\\n### Open Source.\\nMost programming languages today have at least one open-source compiler or interpreter, but some languages\u2014C in particular\u2014are much more closely associated than others with freely distributed, peer-reviewed, community-supported computing. C was originally developed in the early 1970s by Dennis Ritchie and Ken Thompson at Bell Labs,5 in conjunction with the design of the original Unix operating system. Over the years Unix evolved into the world\u2019s most portable operating system\u2014the OS of choice for academic computer science\u2014and C was closely associated with it. With the standardization of C, the language has become available on an enormous variety of additional platforms. Linux, the leading open-source operating system, is written in C. As of October 2008, C and its descendants account for 66% of the projects hosted at the sourceforge.net repository.\\n\\n> \u5982\u4eca\uff0c\u5927\u591a\u6570\u7f16\u7a0b\u8bed\u8a00\u81f3\u5c11\u90fd\u6709\u4e00\u4e2a\u5f00\u6e90\u7f16\u8bd1\u5668\u6216\u89e3\u91ca\u5668\uff0c\u4f46\u6709\u4e9b\u8bed\u8a00\u2014\u2014\u5c24\u5176\u662fC\u8bed\u8a00\u2014\u2014\u4e0e\u81ea\u7531\u5206\u53d1\u3001\u540c\u884c\u8bc4\u5ba1\u3001\u793e\u533a\u652f\u6301\u7684\u8ba1\u7b97\u5bc6\u5207\u76f8\u5173\u3002C\u8bed\u8a00\u6700\u521d\u662f\u572820\u4e16\u7eaa70\u5e74\u4ee3\u521d\u7531\u8d1d\u5c14\u5b9e\u9a8c\u5ba4\u7684\u4e39\u5c3c\u65af\xb7\u91cc\u5947\uff08Dennis Ritchie\uff09\u548c\u80af\xb7\u6c64\u666e\u900a\uff08Ken Thompson\uff09\u5f00\u53d1\u7684\uff0c\u540c\u65f6\u4e5f\u662f\u4e0e\u6700\u521d\u7684Unix\u64cd\u4f5c\u7cfb\u7edf\u7684\u8bbe\u8ba1\u76f8\u5173\u8054\u7684\u3002\u591a\u5e74\u6765\uff0cUnix\u53d1\u5c55\u6210\u4e3a\u4e16\u754c\u4e0a\u6700\u5177\u53ef\u79fb\u690d\u6027\u7684\u64cd\u4f5c\u7cfb\u7edf\u2014\u2014\u6210\u4e3a\u5b66\u672f\u8ba1\u7b97\u673a\u79d1\u5b66\u7684\u9996\u9009\u64cd\u4f5c\u7cfb\u7edf\uff0c\u5e76\u4e0eC\u8bed\u8a00\u5bc6\u5207\u76f8\u5173\u3002\u968f\u7740C\u8bed\u8a00\u7684\u6807\u51c6\u5316\uff0c\u8be5\u8bed\u8a00\u5df2\u7ecf\u53ef\u4ee5\u5728\u5927\u91cf\u989d\u5916\u7684\u5e73\u53f0\u4e0a\u4f7f\u7528\u3002\u9886\u5148\u7684\u5f00\u6e90\u64cd\u4f5c\u7cfb\u7edfLinux\u5c31\u662f\u7528C\u8bed\u8a00\u7f16\u5199\u7684\u3002\u622a\u81f32008\u5e7410\u6708\uff0c\u5728sourceforge.net\u4ee3\u7801\u5e93\u6258\u7ba1\u7684\u9879\u76ee\u4e2d\uff0cC\u8bed\u8a00\u53ca\u5176\u884d\u751f\u7248\u672c\u5360\u4e8666%\u3002\\n\\n### Excellent Compilers.\\nFortran owes much of its success to extremely good compilers. In part this is a matter of historical accident. Fortran has been around longer than anything else, and companies have invested huge amounts of time and money in making compilers that generate very fast code. It is also a matter of language design, however: Fortran dialects prior to Fortran 90 lack recursion and pointers, features that greatly complicate the task of generating fast code (at least for programs that can be written in a reasonable fashion without them!). In a similar vein, some languages (e.g., Common Lisp) are successful in part because they have compilers and supporting tools that do an unusually good job of helping the programmer manage very large projects.\\n\\n> Fortran\u7684\u6210\u529f\u5f88\u5927\u7a0b\u5ea6\u4e0a\u5f52\u529f\u4e8e\u975e\u5e38\u4f18\u79c0\u7684\u7f16\u8bd1\u5668\u3002\u90e8\u5206\u539f\u56e0\u662f\u5386\u53f2\u7684\u5076\u7136\u6027\u3002Fortran\u7684\u5386\u53f2\u6bd4\u5176\u4ed6\u4efb\u4f55\u8bed\u8a00\u90fd\u8981\u60a0\u4e45\uff0c\u8bb8\u591a\u516c\u53f8\u6295\u5165\u4e86\u5927\u91cf\u65f6\u95f4\u548c\u8d44\u91d1\u6765\u5f00\u53d1\u80fd\u591f\u751f\u6210\u975e\u5e38\u9ad8\u6548\u4ee3\u7801\u7684\u7f16\u8bd1\u5668\u3002\u7136\u800c\uff0c\u8fd9\u4e5f\u4e0e\u8bed\u8a00\u8bbe\u8ba1\u6709\u5173\uff1aFortran 90\u4e4b\u524d\u7684\u65b9\u8a00\u7f3a\u4e4f\u9012\u5f52\u548c\u6307\u9488\uff0c\u8fd9\u4e9b\u7279\u6027\u4f1a\u6781\u5927\u5730\u590d\u6742\u5316\u751f\u6210\u9ad8\u6548\u4ee3\u7801\u7684\u4efb\u52a1\uff08\u81f3\u5c11\u5bf9\u4e8e\u53ef\u4ee5\u5728\u4e0d\u4f7f\u7528\u5b83\u4eec\u7684\u60c5\u51b5\u4e0b\u4ee5\u5408\u7406\u65b9\u5f0f\u7f16\u5199\u7684\u7a0b\u5e8f\u6765\u8bf4\u662f\u5982\u6b64\uff01\uff09\u3002\u7c7b\u4f3c\u5730\uff0c\u4e00\u4e9b\u8bed\u8a00\uff08\u4f8b\u5982Common Lisp\uff09\u4e4b\u6240\u4ee5\u6210\u529f\uff0c\u90e8\u5206\u539f\u56e0\u5728\u4e8e\u5b83\u4eec\u5177\u6709\u7f16\u8bd1\u5668\u548c\u652f\u6301\u5de5\u5177\uff0c\u8fd9\u4e9b\u5de5\u5177\u5728\u5e2e\u52a9\u7a0b\u5e8f\u5458\u7ba1\u7406\u975e\u5e38\u5927\u578b\u9879\u76ee\u65b9\u9762\u505a\u5f97\u5f02\u5e38\u51fa\u8272\u3002\\n\\n### Economics, Patronage, and Inertia.\\nFinally, there are factors other than technical merit that greatly influence success. The backing of a powerful sponsor is one. PL/I, at least to first approximation, owes its life to IBM. Cobol and, more recently, Ada owe their life to the U.S. Department of Defense: Ada contains a wealth of excellent features and ideas, but the sheer complexity of implementation would likely have killed it if not for the DoD backing. Similarly, C#, despite its technical merits, would probably not have received the attention it has without the backing of Microsoft. At the other end of the life cycle, some languages remain widely used long after \u201cbetter\u201d alternatives are available because of a huge base of installed software and programmer expertise, which would cost too much to replace.\\n\\n> \u6700\u540e\uff0c\u9664\u4e86\u6280\u672f\u4f18\u52bf\u4e4b\u5916\uff0c\u8fd8\u6709\u5176\u4ed6\u56e0\u7d20\u6781\u5927\u5730\u5f71\u54cd\u7740\u6210\u529f\u3002\u5f3a\u5927\u8d5e\u52a9\u5546\u7684\u652f\u6301\u662f\u5176\u4e2d\u4e4b\u4e00\u3002\u4f8b\u5982\uff0cPL/I\u81f3\u5c11\u5728\u6700\u521d\u9636\u6bb5\uff0c\u5f52\u529f\u4e8eIBM\u3002Cobol\u548c\u6700\u8fd1\u7684Ada\u90fd\u5f52\u529f\u4e8e\u7f8e\u56fd\u56fd\u9632\u90e8\uff1aAda\u5305\u542b\u4e86\u5927\u91cf\u51fa\u8272\u7684\u7279\u6027\u548c\u60f3\u6cd5\uff0c\u4f46\u5982\u679c\u6ca1\u6709\u7f8e\u56fd\u56fd\u9632\u90e8\u7684\u652f\u6301\uff0c\u5176\u5b9e\u73b0\u7684\u590d\u6742\u6027\u5f88\u53ef\u80fd\u4f1a\u4f7f\u5176\u96be\u4ee5\u751f\u5b58\u3002\u540c\u6837\uff0c\u5c3d\u7ba1C#\u5728\u6280\u672f\u4e0a\u6709\u5176\u4f18\u70b9\uff0c\u4f46\u5982\u679c\u6ca1\u6709\u5fae\u8f6f\u7684\u652f\u6301\uff0c\u5b83\u53ef\u80fd\u4e0d\u4f1a\u5f97\u5230\u5982\u4eca\u7684\u5173\u6ce8\u3002\u53e6\u4e00\u65b9\u9762\uff0c\u4e00\u4e9b\u8bed\u8a00\u5728\u66f4\u597d\u7684\u66ff\u4ee3\u65b9\u6848\u51fa\u73b0\u540e\u4ecd\u7136\u88ab\u5e7f\u6cdb\u4f7f\u7528\uff0c\u8fd9\u662f\u56e0\u4e3a\u5df2\u5b89\u88c5\u7684\u8f6f\u4ef6\u548c\u7a0b\u5e8f\u5458\u7684\u4e13\u4e1a\u77e5\u8bc6\u5e9e\u5927\uff0c\u66ff\u6362\u5b83\u4eec\u7684\u6210\u672c\u592a\u9ad8\u3002\\n\\nClearly no single factor determines whether a language is \u201cgood.\u201d As we study programming languages, we shall need to consider issues from several points of view. In particular, we shall need to consider the viewpoints of both the programmer and the language implementor. Sometimes these points of view will be in harmony, as in the desire for execution speed. Often, however, there will be conflicts and tradeoffs, as the conceptual appeal of a feature is balanced against the cost of its implementation. The tradeoff becomes particularly thorny when the implementation imposes costs not only on programs that use the feature, but also on programs that do not.\\n\\n> \u663e\u7136\uff0c\u6ca1\u6709\u5355\u4e00\u56e0\u7d20\u80fd\u51b3\u5b9a\u4e00\u79cd\u8bed\u8a00\u662f\u5426\u201c\u4f18\u79c0\u201d\u3002\u5728\u7814\u7a76\u7f16\u7a0b\u8bed\u8a00\u65f6\uff0c\u6211\u4eec\u9700\u8981\u4ece\u591a\u4e2a\u89d2\u5ea6\u8003\u8651\u95ee\u9898\u3002\u7279\u522b\u662f\uff0c\u6211\u4eec\u9700\u8981\u8003\u8651\u7a0b\u5e8f\u5458\u548c\u8bed\u8a00\u5b9e\u73b0\u8005\u7684\u89c2\u70b9\u3002\u6709\u65f6\u8fd9\u4e9b\u89c2\u70b9\u4f1a\u4fdd\u6301\u4e00\u81f4\uff0c\u6bd4\u5982\u5bf9\u6267\u884c\u901f\u5ea6\u7684\u6e34\u671b\u3002\u7136\u800c\uff0c\u901a\u5e38\u4f1a\u5b58\u5728\u51b2\u7a81\u548c\u6743\u8861\uff0c\u6bd4\u5982\u67d0\u9879\u7279\u6027\u7684\u6982\u5ff5\u5438\u5f15\u529b\u4e0e\u5176\u5b9e\u73b0\u6210\u672c\u4e4b\u95f4\u7684\u5e73\u8861\u3002\u5f53\u5b9e\u73b0\u4e0d\u4ec5\u7ed9\u4f7f\u7528\u8be5\u7279\u6027\u7684\u7a0b\u5e8f\u5e26\u6765\u6210\u672c\uff0c\u800c\u4e14\u4e5f\u7ed9\u4e0d\u4f7f\u7528\u8be5\u7279\u6027\u7684\u7a0b\u5e8f\u5e26\u6765\u6210\u672c\u65f6\uff0c\u8fd9\u79cd\u6743\u8861\u53d8\u5f97\u7279\u522b\u68d8\u624b\u3002\\n\\nIn the early days of computing the implementor\u2019s viewpoint was predominant. Programming languages evolved as a means of telling a computer what to do. For programmers, however, a language is more aptly defined as a means of expressing algorithms. Just as natural languages constrain exposition and discourse, so programming languages constrain what can and cannot easily be expressed, and have both profound and subtle influence over what the programmer can think. Donald Knuth has suggested that programming be regarded as the art of telling another human being what one wants the computer to do [Knu84].6 This definition perhaps strikes the best sort of compromise. It acknowledges that both conceptual clarity and implementation efficiency are fundamental concerns. This book attempts to capture this spirit of compromise,by simultaneously considering the conceptual and implementation aspects of each of the topics it covers.\\n\\n> \u5728\u8ba1\u7b97\u673a\u7684\u65e9\u671f\u53d1\u5c55\u9636\u6bb5\uff0c\u5b9e\u73b0\u8005\u7684\u89c2\u70b9\u5360\u636e\u4e3b\u5bfc\u5730\u4f4d\u3002\u7f16\u7a0b\u8bed\u8a00\u6f14\u53d8\u4e3a\u544a\u8bc9\u8ba1\u7b97\u673a\u8be5\u505a\u4ec0\u4e48\u7684\u624b\u6bb5\u3002\u7136\u800c\uff0c\u5bf9\u4e8e\u7a0b\u5e8f\u5458\u6765\u8bf4\uff0c\u8bed\u8a00\u66f4\u6070\u5f53\u5730\u88ab\u5b9a\u4e49\u4e3a\u8868\u8fbe\u7b97\u6cd5\u7684\u624b\u6bb5\u3002\u5c31\u50cf\u81ea\u7136\u8bed\u8a00\u9650\u5236\u4e86\u8868\u8ff0\u548c\u4ea4\u6d41\u4e00\u6837\uff0c\u7f16\u7a0b\u8bed\u8a00\u4e5f\u9650\u5236\u4e86\u4ec0\u4e48\u53ef\u4ee5\u548c\u4e0d\u80fd\u8f7b\u677e\u5730\u8868\u8fbe\uff0c\u5e76\u5bf9\u7a0b\u5e8f\u5458\u7684\u601d\u7ef4\u4ea7\u751f\u6df1\u8fdc\u800c\u5fae\u5999\u7684\u5f71\u54cd\u3002Donald Knuth\u66fe\u5efa\u8bae\u5c06\u7f16\u7a0b\u89c6\u4e3a\u544a\u8bc9\u53e6\u4e00\u4e2a\u4eba\u60f3\u8ba9\u8ba1\u7b97\u673a\u505a\u4ec0\u4e48\u7684\u827a\u672f\u3002\u8fd9\u4e2a\u5b9a\u4e49\u6216\u8bb8\u8fbe\u5230\u4e86\u6700\u597d\u7684\u6298\u8877\u3002\u5b83\u627f\u8ba4\u4e86\u6982\u5ff5\u4e0a\u7684\u6e05\u6670\u548c\u5b9e\u73b0\u6548\u7387\u90fd\u662f\u57fa\u672c\u5173\u6ce8\u70b9\u3002\u672c\u4e66\u8bd5\u56fe\u6355\u6349\u8fd9\u79cd\u6298\u8877\u7684\u7cbe\u795e\uff0c\u540c\u65f6\u8003\u8651\u6240\u6db5\u76d6\u4e3b\u9898\u7684\u6982\u5ff5\u548c\u5b9e\u73b0\u65b9\u9762\u3002"},{"id":"/2024/programming-language-pragmatics-02","metadata":{"permalink":"/blog/2024/programming-language-pragmatics-02","source":"@site/blog/2024/programming-language-pragmatics-02.md","title":"Programming Language Pragmatics \u7b2c\u4e00\u7ae0\u7b14\u8bb0\u4e0b","description":"An Overview of Compilation","date":"2024-01-25T08:06:02.000Z","tags":[{"label":"\u7f16\u8bd1\u5668","permalink":"/blog/tags/\u7f16\u8bd1\u5668"},{"label":"Programming Language Pragmatics","permalink":"/blog/tags/programming-language-pragmatics"}],"readingTime":31.75,"hasTruncateMarker":false,"authors":[],"frontMatter":{"title":"Programming Language Pragmatics \u7b2c\u4e00\u7ae0\u7b14\u8bb0\u4e0b","tags":["\u7f16\u8bd1\u5668","Programming Language Pragmatics"]},"unlisted":false,"prevItem":{"title":"Programming Language Pragmatics \u7b2c\u4e00\u7ae0\u7b14\u8bb0\u4e0a","permalink":"/blog/2024/programming-language-pragmatics-01"}},"content":"## An Overview of Compilation\\nCompilers are among the most well-studied classes of computer programs. We will consider them repeatedly throughout the rest of the book, and in Chapters 2, 4, 14, and 16 in particular. The remainder of this section provides an introductory overview.\\n\\n> \u7f16\u8bd1\u5668\u662f\u6700\u53d7\u4eba\u7814\u7a76\u7684\u8ba1\u7b97\u673a\u7a0b\u5e8f\u7c7b\u522b\u4e4b\u4e00\u3002\u6211\u4eec\u5c06\u5728\u672c\u4e66\u7684\u5176\u4f59\u90e8\u5206\u591a\u6b21\u8003\u8651\u5b83\u4eec\uff0c\u7279\u522b\u662f\u5728\u7b2c2\u30014\u300114\u548c16\u7ae0\u3002\u672c\u8282\u7684\u5176\u4f59\u90e8\u5206\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7b80\u8981\u6982\u8ff0\u3002\\n\\n![](https://misakatang.oss-cn-beijing.aliyuncs.com/blog_picture/Snipaste_2023-11-15_15-40-01.png)\\n\\nIn a typical compiler, compilation proceeds through a series of well-defined phases, shown in Figure 1.3. Each phase discovers information of use to later phases, or transforms the program into a form that is more useful to the subsequent phase.\\n\\n> \u5728\u5178\u578b\u7684\u7f16\u8bd1\u5668\u4e2d\uff0c\u7f16\u8bd1\u8fc7\u7a0b\u7ecf\u8fc7\u4e00\u7cfb\u5217\u660e\u786e\u5b9a\u4e49\u7684\u9636\u6bb5\uff0c\u5982\u56fe1.3\u6240\u793a\u3002\u6bcf\u4e2a\u9636\u6bb5\u90fd\u4f1a\u53d1\u73b0\u5bf9\u540e\u7eed\u9636\u6bb5\u6709\u7528\u7684\u4fe1\u606f\uff0c\u6216\u5c06\u7a0b\u5e8f\u8f6c\u6362\u4e3a\u5bf9\u540e\u7eed\u9636\u6bb5\u66f4\u6709\u7528\u7684\u5f62\u5f0f\u3002\\n\\nThe first few phases (up through semantic analysis) serve to figure out the meaning of the source program. They are sometimes called the front end of the compiler. The last few phases serve to construct an equivalent target program. They are sometimes called the back end of the compiler. Many compiler phases can be created automatically from a formal description of the source and/or target languages.\\n\\n> \u524d\u51e0\u4e2a\u9636\u6bb5\uff08\u76f4\u5230\u8bed\u4e49\u5206\u6790\uff09\u7528\u4e8e\u5f04\u6e05\u6e90\u7a0b\u5e8f\u7684\u542b\u4e49\u3002\u5b83\u4eec\u6709\u65f6\u88ab\u79f0\u4e3a\u7f16\u8bd1\u5668\u7684\u524d\u7aef\u3002\u6700\u540e\u51e0\u4e2a\u9636\u6bb5\u7528\u4e8e\u6784\u5efa\u4e00\u4e2a\u7b49\u4ef7\u7684\u76ee\u6807\u7a0b\u5e8f\u3002\u5b83\u4eec\u6709\u65f6\u88ab\u79f0\u4e3a\u7f16\u8bd1\u5668\u7684\u540e\u7aef\u3002\u8bb8\u591a\u7f16\u8bd1\u5668\u9636\u6bb5\u53ef\u4ee5\u6839\u636e\u6e90\u8bed\u8a00\u548c/\u6216\u76ee\u6807\u8bed\u8a00\u7684\u5f62\u5f0f\u5316\u63cf\u8ff0\u81ea\u52a8\u751f\u6210\u3002\\n\\nOne will sometimes hear compilation described as a series of passes. A pass is a phase or set of phases that is serialized with respect to the rest of compilation: it does not start until previous phases have completed, and it finishes before any subsequent phases start. If desired, a pass may be written as a separate program, reading its input from a file and writing its output to a file. Compilers are commonly divided into passes so that the front end may be shared by compilers for more than one machine (target language), and so that the back end may be shared by compilers for more than one source language. In some implementations the front end and the back end may be separated by a\u201cmiddle end\u201dthat is responsible for language- and machine-independent code improvement. Prior to the dramatic increases in memory sizes of the mid to late 1980s, compilers were also sometimes divided into passes to minimize memory usage: as each pass completed, the next could reuse its code space.\\n\\n> \u6709\u65f6\u4f1a\u542c\u5230\u5c06\u7f16\u8bd1\u63cf\u8ff0\u4e3a\u4e00\u7cfb\u5217\u4f20\u9012\u3002\u4f20\u9012\u662f\u4e00\u4e2a\u76f8\u5bf9\u4e8e\u7f16\u8bd1\u7684\u5176\u4f59\u90e8\u5206\u8fdb\u884c\u4e32\u884c\u5316\u7684\u9636\u6bb5\u6216\u4e00\u7ec4\u9636\u6bb5\uff1a\u5b83\u5728\u524d\u4e00\u9636\u6bb5\u5b8c\u6210\u4e4b\u524d\u4e0d\u4f1a\u5f00\u59cb\uff0c\u5e76\u4e14\u5728\u4efb\u4f55\u540e\u7eed\u9636\u6bb5\u5f00\u59cb\u4e4b\u524d\u5c31\u4f1a\u7ed3\u675f\u3002\u5982\u679c\u9700\u8981\uff0c\u53ef\u4ee5\u5c06\u4f20\u9012\u7f16\u5199\u4e3a\u4e00\u4e2a\u72ec\u7acb\u7684\u7a0b\u5e8f\uff0c\u4ece\u6587\u4ef6\u8bfb\u53d6\u8f93\u5165\u5e76\u5c06\u8f93\u51fa\u5199\u5165\u6587\u4ef6\u3002\u7f16\u8bd1\u5668\u901a\u5e38\u88ab\u5212\u5206\u4e3a\u4f20\u9012\uff0c\u4ee5\u4fbf\u524d\u7aef\u53ef\u4ee5\u88ab\u591a\u53f0\u673a\u5668\uff08\u76ee\u6807\u8bed\u8a00\uff09\u7684\u7f16\u8bd1\u5668\u5171\u4eab\uff0c\u540e\u7aef\u53ef\u4ee5\u88ab\u591a\u79cd\u6e90\u8bed\u8a00\u7684\u7f16\u8bd1\u5668\u5171\u4eab\u3002\u5728\u4e00\u4e9b\u5b9e\u73b0\u4e2d\uff0c\u524d\u7aef\u548c\u540e\u7aef\u53ef\u80fd\u88ab\u4e00\u4e2a\u8d1f\u8d23\u8bed\u8a00\u548c\u673a\u5668\u65e0\u5173\u4ee3\u7801\u6539\u8fdb\u7684\u201c\u4e2d\u7aef\u201d\u5206\u5f00\u3002\u572820\u4e16\u7eaa80\u5e74\u4ee3\u4e2d\u671f\u5230\u665a\u671f\u5185\u5b58\u5927\u5c0f\u5927\u5e45\u589e\u52a0\u4e4b\u524d\uff0c\u6709\u65f6\u4e5f\u5c06\u7f16\u8bd1\u5668\u5212\u5206\u4e3a\u4f20\u9012\u4ee5\u6700\u5c0f\u5316\u5185\u5b58\u4f7f\u7528\uff1a\u5f53\u6bcf\u4e2a\u4f20\u9012\u5b8c\u6210\u65f6\uff0c\u4e0b\u4e00\u4e2a\u4f20\u9012\u53ef\u4ee5\u91cd\u7528\u5176\u4ee3\u7801\u7a7a\u95f4\u3002\\n\\n### Lexical and Syntax Analysis\\nScanning is also known as lexical analysis. The principal purpose of the scanner is to simplify the task of the parser, by reducing the size of the input (there are many more characters than tokens) and by removing extraneous characters like white space. The scanner also typically removes comments and tags tokens with line and column numbers, to make it easier to generate good diagnostics in later phases. One could design a parser to take characters instead of tokens as inputdispensing with the scanner\u2014but the result would be awkward and slow.\\n\\n> \u626b\u63cf\u4e5f\u88ab\u79f0\u4e3a\u8bcd\u6cd5\u5206\u6790\u3002\u626b\u63cf\u5668\u7684\u4e3b\u8981\u76ee\u7684\u662f\u7b80\u5316\u89e3\u6790\u5668\u7684\u4efb\u52a1\uff0c\u901a\u8fc7\u51cf\u5c11\u8f93\u5165\u7684\u5927\u5c0f\uff08\u5b57\u7b26\u6bd4\u6807\u8bb0\u8981\u591a\u5f97\u591a\uff09\uff0c\u5e76\u5220\u9664\u591a\u4f59\u7684\u5b57\u7b26\uff0c\u5982\u7a7a\u767d\u3002\u626b\u63cf\u5668\u901a\u5e38\u8fd8\u4f1a\u79fb\u9664\u6ce8\u91ca\uff0c\u5e76\u4e3a\u6807\u8bb0\u6dfb\u52a0\u884c\u53f7\u548c\u5217\u53f7\uff0c\u4ee5\u4fbf\u5728\u540e\u7eed\u9636\u6bb5\u66f4\u5bb9\u6613\u751f\u6210\u826f\u597d\u7684\u8bca\u65ad\u4fe1\u606f\u3002\u7406\u8bba\u4e0a\u53ef\u4ee5\u8bbe\u8ba1\u4e00\u4e2a\u89e3\u6790\u5668\uff0c\u63a5\u53d7\u5b57\u7b26\u800c\u4e0d\u662f\u6807\u8bb0\u4f5c\u4e3a\u8f93\u5165\uff0c\u4ece\u800c\u7701\u53bb\u626b\u63cf\u5668\uff0c\u4f46\u7ed3\u679c\u4f1a\u5f88\u7b28\u62d9\u4e14\u6548\u7387\u4f4e\u4e0b\u3002\\n\\nParsing organizes tokens into a parse tree that represents higher-level constructs (statements, expressions, subroutines, and so on) in terms of their constituents. Each construct is a node in the tree; its constituents are its children. The root ofthe tree is simply \u201cprogram\u201d; the leaves, from left to right, are the tokens received from the scanner. Taken as a whole, the tree shows how the tokens fit together to make a valid program. The structure relies on a set of potentially recursive rules known as a context-free grammar. Each rule has an arrow sign (\u2212\u2192) with the construct name on the left and a possible expansion on the right. In C, for example, a while loop consists of the keyword while followed by a parenthesized Boolean expression and a statement:\\n\\n> \u89e3\u6790\u5c06\u6807\u8bb0\u7ec4\u7ec7\u6210\u4e00\u4e2a\u89e3\u6790\u6811\uff0c\u8be5\u6811\u4ee5\u5176\u7ec4\u6210\u90e8\u5206\u8868\u793a\u9ad8\u7ea7\u6784\u9020\uff08\u8bed\u53e5\u3001\u8868\u8fbe\u5f0f\u3001\u5b50\u7a0b\u5e8f\u7b49\uff09\u3002\u6bcf\u4e2a\u6784\u9020\u90fd\u662f\u6811\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\uff1b\u5b83\u7684\u7ec4\u6210\u90e8\u5206\u662f\u5b83\u7684\u5b50\u8282\u70b9\u3002\u6811\u7684\u6839\u8282\u70b9\u7b80\u5355\u5730\u662f\u201c\u7a0b\u5e8f\u201d\uff1b\u4ece\u5de6\u5230\u53f3\u7684\u53f6\u5b50\u8282\u70b9\u662f\u6765\u81ea\u626b\u63cf\u5668\u7684\u6807\u8bb0\u3002\u6574\u4f53\u4e0a\u770b\uff0c\u6811\u663e\u793a\u4e86\u6807\u8bb0\u5982\u4f55\u7ec4\u5408\u5728\u4e00\u8d77\u5f62\u6210\u4e00\u4e2a\u6709\u6548\u7684\u7a0b\u5e8f\u3002\u8be5\u7ed3\u6784\u4f9d\u8d56\u4e8e\u4e00\u7ec4\u6f5c\u5728\u9012\u5f52\u7684\u89c4\u5219\uff0c\u79f0\u4e3a\u65e0\u4e0a\u4e0b\u6587\u8bed\u6cd5\u3002\u6bcf\u4e2a\u89c4\u5219\u90fd\u6709\u4e00\u4e2a\u7bad\u5934\u7b26\u53f7\uff08\u2192\uff09\uff0c\u5de6\u8fb9\u662f\u6784\u9020\u540d\u79f0\uff0c\u53f3\u8fb9\u662f\u53ef\u80fd\u7684\u6269\u5c55\u3002\u4f8b\u5982\uff0c\u5728C\u8bed\u8a00\u4e2d\uff0cwhile\u5faa\u73af\u7531\u5173\u952e\u5b57while\u540e\u8ddf\u62ec\u53f7\u4e2d\u7684\u5e03\u5c14\u8868\u8fbe\u5f0f\u548c\u4e00\u4e2a\u8bed\u53e5\u7ec4\u6210\uff1a\\n\\n```\\niteration-statement \u2212\u2192 while ( expression ) statement\\n```\\nThe statement, in turn, is often a list enclosed in braces:\\n```\\nstatement \u2212\u2192 compound-statement\\ncompound-statement \u2212\u2192 { block-item-list opt }\\n```\\nwhere\\n```\\nblock-item-list opt \u2212\u2192 block-item-list\\n```\\nor\\n```\\nblock-item-list opt \u2212\u2192 \u03f5\\n```\\nand\\n```\\nblock-item-list \u2212\u2192 block-item\\nblock-item-list \u2212\u2192 block-item-list block-item\\nblock-item \u2212\u2192 declaration\\nblock-item \u2212\u2192 statement\\n```\\nHere \u03f5 represents the empty string; it indicates that block-item-list opt can simply be deleted. Many more grammar rules are needed, of course, to explain the full structure of a program.\\n\\n> \u8fd9\u91cc\u7684 \u03f5 \u4ee3\u8868\u7a7a\u5b57\u7b26\u4e32\uff1b\u5b83\u8868\u793a block-item-list opt \u53ef\u4ee5\u88ab\u7b80\u5355\u5730\u5220\u9664\u3002\u5f53\u7136\uff0c\u9700\u8981\u66f4\u591a\u7684\u8bed\u6cd5\u89c4\u5219\u6765\u89e3\u91ca\u7a0b\u5e8f\u7684\u5b8c\u6574\u7ed3\u6784\u3002\\n\\nA context-free grammar is said to define the syntax of the language; parsing is therefore known as syntax analysis. There are many possible grammars for C (an infinite number, in fact); the fragment shown above is taken from the sample grammar contained in the official language definition [Int99]. A full parse tree for our GCD program (based on a full grammar not shown here) appears in Figure 1.4. While the size of the tree may seem daunting, its details aren\u2019t particularly important at this point in the text. What is important is that (1) each individual branching point represents the application of a single grammar rule, and (2) the resulting complexity is more a reflection of the grammar than it is of the input program. Much of it stems from (a) the use of such artificial \u201cconstructs\u201d as block item-list and block item-list opt to generate lists of arbitrary length, and (b) the use of the equally artificial assignment-expression, additive expression, multiplicative-expression, and so on, to capture precedence and associativity in arithmetic expressions. We shall see in the following subsection that much of this complexity can be discarded once parsing is complete.\\n\\n> \u4e00\u4e2a\u65e0\u4e0a\u4e0b\u6587\u8bed\u6cd5\u88ab\u8ba4\u4e3a\u5b9a\u4e49\u4e86\u8bed\u8a00\u7684\u8bed\u6cd5\uff1b\u56e0\u6b64\uff0c\u89e3\u6790\u4e5f\u88ab\u79f0\u4e3a\u8bed\u6cd5\u5206\u6790\u3002\u5bf9\u4e8eC\u8bed\u8a00\u6709\u8bb8\u591a\u53ef\u80fd\u7684\u8bed\u6cd5\uff08\u5b9e\u9645\u4e0a\u662f\u65e0\u9650\u591a\u4e2a\uff09\uff1b\u4e0a\u9762\u663e\u793a\u7684\u7247\u6bb5\u53d6\u81ea\u5b98\u65b9\u8bed\u8a00\u5b9a\u4e49\u4e2d\u5305\u542b\u7684\u6837\u4f8b\u8bed\u6cd5[Int99]\u3002\u57fa\u4e8e\u672a\u5728\u6b64\u5904\u663e\u793a\u7684\u5b8c\u6574\u8bed\u6cd5\u7684\u6211\u4eec\u7684GCD\u7a0b\u5e8f\u7684\u5b8c\u6574\u89e3\u6790\u6811\u663e\u793a\u5728\u56fe1.4\u4e2d\u3002\u867d\u7136\u6811\u7684\u5927\u5c0f\u53ef\u80fd\u770b\u8d77\u6765\u4ee4\u4eba\u751f\u754f\uff0c\u4f46\u5728\u672c\u6587\u7684\u8fd9\u4e00\u9636\u6bb5\uff0c\u5176\u7ec6\u8282\u5e76\u4e0d\u7279\u522b\u91cd\u8981\u3002\u91cd\u8981\u7684\u662f\uff1a\uff081\uff09\u6bcf\u4e2a\u5355\u72ec\u7684\u5206\u652f\u70b9\u4ee3\u8868\u4e00\u4e2a\u5355\u4e00\u7684\u8bed\u6cd5\u89c4\u5219\u7684\u5e94\u7528\uff0c\u4ee5\u53ca\uff082\uff09\u4ea7\u751f\u7684\u590d\u6742\u6027\u66f4\u591a\u5730\u53cd\u6620\u4e86\u8bed\u6cd5\u800c\u4e0d\u662f\u8f93\u5165\u7a0b\u5e8f\u672c\u8eab\u3002\u5176\u4e2d\u8bb8\u591a\u590d\u6742\u6027\u6e90\u81ea\u4e8e\uff08a\uff09\u4f7f\u7528\u8bf8\u5982 block item-list \u548c block item-list opt \u4e4b\u7c7b\u7684\u4eba\u4e3a\u201c\u6784\u9020\u201d\u6765\u751f\u6210\u4efb\u610f\u957f\u5ea6\u7684\u5217\u8868\uff0c\u4ee5\u53ca\uff08b\uff09\u4f7f\u7528\u540c\u6837\u4eba\u4e3a\u7684 assignment-expression\u3001additive-expression\u3001multiplicative-expression \u7b49\u6765\u6355\u83b7\u7b97\u672f\u8868\u8fbe\u5f0f\u4e2d\u7684\u4f18\u5148\u7ea7\u548c\u7ed3\u5408\u6027\u3002\u5728\u63a5\u4e0b\u6765\u7684\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u770b\u5230\u4e00\u65e6\u89e3\u6790\u5b8c\u6210\uff0c\u8bb8\u591a\u8fd9\u4e9b\u590d\u6742\u6027\u90fd\u53ef\u4ee5\u88ab\u4e22\u5f03\u3002\\n\\nIn the process of scanning and parsing, the compiler checks to see that all of the program\u2019s tokens are well formed, and that the sequence of tokens conforms to the syntax defined by the context-free grammar. Any malformed tokens (e.g., 123abc or $@foo in C) should cause the scanner to produce an error message. Any syntactically invalid token sequence (e.g., A = X Y Z in C) should lead to an error message from the parser.\\n\\n> \u5728\u626b\u63cf\u548c\u89e3\u6790\u7684\u8fc7\u7a0b\u4e2d\uff0c\u7f16\u8bd1\u5668\u68c0\u67e5\u7a0b\u5e8f\u7684\u6240\u6709\u6807\u8bb0\u662f\u5426\u683c\u5f0f\u826f\u597d\uff0c\u5e76\u4e14\u6807\u8bb0\u5e8f\u5217\u662f\u5426\u7b26\u5408\u4e0a\u4e0b\u6587\u65e0\u5173\u8bed\u6cd5\u5b9a\u4e49\u7684\u8bed\u6cd5\u3002\u4efb\u4f55\u683c\u5f0f\u4e0d\u826f\u7684\u6807\u8bb0\uff08\u4f8b\u5982\uff0c\u5728C\u8bed\u8a00\u4e2d\u7684123abc\u6216$@foo\uff09\u90fd\u5e94\u8be5\u5bfc\u81f4\u626b\u63cf\u5668\u4ea7\u751f\u9519\u8bef\u6d88\u606f\u3002\u4efb\u4f55\u8bed\u6cd5\u4e0a\u65e0\u6548\u7684\u6807\u8bb0\u5e8f\u5217\uff08\u4f8b\u5982\uff0c\u5728C\u8bed\u8a00\u4e2d\u7684A = X Y Z\uff09\u5e94\u8be5\u5bfc\u81f4\u89e3\u6790\u5668\u4ea7\u751f\u9519\u8bef\u6d88\u606f\u3002\\n\\n### Semantic Analysis and Intermediate Code Generation\\nSemantic analysis is the discovery of meaning in a program. The semantic analysis phase of compilation recognizes when multiple occurrences of the same identifier are meant to refer to the same program entity,and ensures that the uses are consistent. In most languages the semantic analyzer tracks the types of both identifiers and expressions, both to verify consistent usage and to guide the generation of code in later phases.\\n\\n> \u8bed\u4e49\u5206\u6790\u662f\u5bf9\u7a0b\u5e8f\u4e2d\u542b\u4e49\u7684\u53d1\u73b0\u3002\u7f16\u8bd1\u7684\u8bed\u4e49\u5206\u6790\u9636\u6bb5\u8bc6\u522b\u4e86\u76f8\u540c\u6807\u8bc6\u7b26\u7684\u591a\u6b21\u51fa\u73b0\u610f\u5473\u7740\u5f15\u7528\u540c\u4e00\u7a0b\u5e8f\u5b9e\u4f53\uff0c\u5e76\u786e\u4fdd\u8fd9\u4e9b\u7528\u6cd5\u662f\u4e00\u81f4\u7684\u3002\u5728\u5927\u591a\u6570\u8bed\u8a00\u4e2d\uff0c\u8bed\u4e49\u5206\u6790\u5668\u8ddf\u8e2a\u6807\u8bc6\u7b26\u548c\u8868\u8fbe\u5f0f\u7684\u7c7b\u578b\uff0c\u65e2\u7528\u4e8e\u9a8c\u8bc1\u4e00\u81f4\u7684\u4f7f\u7528\uff0c\u4e5f\u7528\u4e8e\u6307\u5bfc\u540e\u7eed\u9636\u6bb5\u4ee3\u7801\u7684\u751f\u6210\u3002\\n\\nTo assist in its work,the semantic analyzer typically builds and maintains a symbol table data structure that maps each identifier to the information known about it. Among other things, this information includes the identifier\u2019s type, internal structure (if any), and scope (the portion of the program in which it is valid).\\n\\n> \u4e3a\u4e86\u8f85\u52a9\u5176\u5de5\u4f5c\uff0c\u8bed\u4e49\u5206\u6790\u5668\u901a\u5e38\u6784\u5efa\u5e76\u7ef4\u62a4\u4e00\u4e2a\u7b26\u53f7\u8868\u6570\u636e\u7ed3\u6784\uff0c\u5c06\u6bcf\u4e2a\u6807\u8bc6\u7b26\u6620\u5c04\u5230\u5df2\u77e5\u7684\u4fe1\u606f\u3002\u8fd9\u4e9b\u4fe1\u606f\u5305\u62ec\u6807\u8bc6\u7b26\u7684\u7c7b\u578b\u3001\u5185\u90e8\u7ed3\u6784\uff08\u5982\u679c\u6709\u7684\u8bdd\uff09\u4ee5\u53ca\u4f5c\u7528\u57df\uff08\u5176\u6709\u6548\u7684\u7a0b\u5e8f\u90e8\u5206\uff09\u3002\\n\\nUsing the symbol table, the semantic analyzer enforces a large variety of rules that are not captured by the hierarchical structure of the context-free grammar and the parse tree. In C, for example, it checks to make sure that\\n\\n> \u5229\u7528\u7b26\u53f7\u8868\uff0c\u8bed\u4e49\u5206\u6790\u5668\u5f3a\u5236\u6267\u884c\u8bb8\u591a\u4e0a\u4e0b\u6587\u65e0\u5173\u8bed\u6cd5\u548c\u89e3\u6790\u6811\u6240\u4e0d\u80fd\u6355\u83b7\u7684\u89c4\u5219\u3002\u4f8b\u5982\uff0c\u5728C\u8bed\u8a00\u4e2d\uff0c\u5b83\u4f1a\u68c0\u67e5\u786e\u4fdd\\n\\n- Every identifier is declared before it is used.\\n- No identifier is used in an inappropriate context (calling an integer as a subroutine, adding a string to an integer, referencing a field of the wrong type of struct, etc.).\\n- Subroutine calls provide the correct number and types of arguments.\\n- Labels on the arms of a switch statement are distinct constants.\\n- Any function with a non-void return type returns a value explicitly.\\n\\nIn many compilers, the work of the semantic analyzer takes the form of semantic action routines,invoked by the parser when it realizes that it has reached a particular point within a grammar rule.\\n\\n> \u5728\u8bb8\u591a\u7f16\u8bd1\u5668\u4e2d\uff0c\u8bed\u4e49\u5206\u6790\u5668\u7684\u5de5\u4f5c\u4ee5\u8bed\u4e49\u52a8\u4f5c\u4f8b\u7a0b\u7684\u5f62\u5f0f\u8fdb\u884c\uff0c\u5f53\u89e3\u6790\u5668\u610f\u8bc6\u5230\u5df2\u7ecf\u5230\u8fbe\u8bed\u6cd5\u89c4\u5219\u4e2d\u7684\u7279\u5b9a\u70b9\u65f6\uff0c\u4f1a\u8c03\u7528\u8fd9\u4e9b\u4f8b\u7a0b\u3002\\n\\nOf course, not all semantic rules can be checked at compile time. Those that can are referred to as the static semantics of the language. Those that must be checked at run time are referred to as the dynamic semantics of the language. C has very little in the way of dynamic checks (its designers opted for performance over safety). Examples of rules that other languages enforce at run time include the following.\\n\\n> \u5f53\u7136\uff0c\u5e76\u975e\u6240\u6709\u7684\u8bed\u4e49\u89c4\u5219\u90fd\u80fd\u5728\u7f16\u8bd1\u65f6\u8fdb\u884c\u68c0\u67e5\u3002\u90a3\u4e9b\u53ef\u4ee5\u5728\u7f16\u8bd1\u65f6\u68c0\u67e5\u7684\u89c4\u5219\u88ab\u79f0\u4e3a\u8bed\u8a00\u7684\u9759\u6001\u8bed\u4e49\u3002\u90a3\u4e9b\u5fc5\u987b\u5728\u8fd0\u884c\u65f6\u68c0\u67e5\u7684\u89c4\u5219\u88ab\u79f0\u4e3a\u8bed\u8a00\u7684\u52a8\u6001\u8bed\u4e49\u3002C\u8bed\u8a00\u5728\u52a8\u6001\u68c0\u67e5\u65b9\u9762\u51e0\u4e4e\u6ca1\u6709\u4ec0\u4e48\uff08\u5176\u8bbe\u8ba1\u8005\u9009\u62e9\u4e86\u6027\u80fd\u800c\u4e0d\u662f\u5b89\u5168\u6027\uff09\u3002\u5176\u4ed6\u8bed\u8a00\u5728\u8fd0\u884c\u65f6\u6267\u884c\u7684\u89c4\u5219\u7684\u4f8b\u5b50\u5305\u62ec\u4ee5\u4e0b\u5185\u5bb9\u3002\\n\\n- Variables are never used in an expression unless they have been given a value.\\n- Pointers are never dereferenced unless they refer to a valid object.\\n- Array subscript expressions lie within the bounds of the array.\\n- Arithmetic operations do not overflow.\\n\\nWhen it cannot enforce rules statically, a compiler will often produce code to perform appropriate checks at run time, aborting the program or generating an exception if one of the checks then fails. (Exceptions will be discussed in Section 8.5.) Some rules, unfortunately, may be unacceptably expensive or impossible to enforce, and the language implementation may simply fail to check them. In Ada, a program that breaks such a rule is said to be erroneous; in C its behavior is said to be undefined.\\n\\n> \u5f53\u7f16\u8bd1\u5668\u65e0\u6cd5\u9759\u6001\u5730\u5f3a\u5236\u6267\u884c\u89c4\u5219\u65f6\uff0c\u901a\u5e38\u4f1a\u751f\u6210\u4ee3\u7801\uff0c\u5728\u8fd0\u884c\u65f6\u6267\u884c\u9002\u5f53\u7684\u68c0\u67e5\uff0c\u5982\u679c\u5176\u4e2d\u4e00\u4e2a\u68c0\u67e5\u5931\u8d25\uff0c\u5219\u4e2d\u6b62\u7a0b\u5e8f\u6216\u751f\u6210\u5f02\u5e38\uff08\u5f02\u5e38\u5c06\u5728\u7b2c8.5\u8282\u4e2d\u8ba8\u8bba\uff09\u3002\u9057\u61be\u7684\u662f\uff0c\u4e00\u4e9b\u89c4\u5219\u53ef\u80fd\u6210\u672c\u8fc7\u9ad8\u6216\u65e0\u6cd5\u5b9e\u65bd\uff0c\u8bed\u8a00\u5b9e\u73b0\u53ef\u80fd\u4f1a\u7b80\u5355\u5730\u4e0d\u5bf9\u5176\u8fdb\u884c\u68c0\u67e5\u3002\u5728Ada\u4e2d\uff0c\u8fdd\u53cd\u6b64\u7c7b\u89c4\u5219\u7684\u7a0b\u5e8f\u88ab\u79f0\u4e3a\u9519\u8bef\u7684\uff1b\u5728C\u4e2d\uff0c\u5176\u884c\u4e3a\u88ab\u79f0\u4e3a\u672a\u5b9a\u4e49\u3002\\n\\nA parse tree is sometimes known as a concrete syntax tree, because it demonstrates, completely and concretely, how a particular sequence of tokens can be derived under the rules of the context-free grammar. Once we know that a token sequence is valid, however, much of the information in the parse tree is irrelevant to further phases of compilation. In the process of checking static semantic rules, the semantic analyzer typically transforms the parse tree into an abstract syntax tree (otherwise known as an AST,or simply a syntax tree) by removing most of the \u201cartificial\u201d nodes in the tree\u2019s interior. The semantic analyzer also annotates the remaining nodes with useful information,such as pointers from identifiers to their symbol table entries. The annotations attached to a particular node are known as its attributes. A syntax tree for our GCD program is shown in Figure 1.5.\\n\\n> \u89e3\u6790\u6811\u6709\u65f6\u88ab\u79f0\u4e3a\u5177\u4f53\u8bed\u6cd5\u6811\uff0c\u56e0\u4e3a\u5b83\u5b8c\u5168\u800c\u5177\u4f53\u5730\u5c55\u793a\u4e86\u5728\u4e0a\u4e0b\u6587\u65e0\u5173\u6587\u6cd5\u89c4\u5219\u4e0b\u7279\u5b9a\u6807\u8bb0\u5e8f\u5217\u7684\u63a8\u5bfc\u8fc7\u7a0b\u3002\u7136\u800c\uff0c\u4e00\u65e6\u6211\u4eec\u77e5\u9053\u4e00\u4e2a\u6807\u8bb0\u5e8f\u5217\u662f\u6709\u6548\u7684\uff0c\u89e3\u6790\u6811\u4e2d\u7684\u5927\u90e8\u5206\u4fe1\u606f\u5bf9\u4e8e\u7f16\u8bd1\u7684\u540e\u7eed\u9636\u6bb5\u6765\u8bf4\u5c31\u53d8\u5f97\u65e0\u5173\u7d27\u8981\u4e86\u3002\u5728\u68c0\u67e5\u9759\u6001\u8bed\u4e49\u89c4\u5219\u7684\u8fc7\u7a0b\u4e2d\uff0c\u8bed\u4e49\u5206\u6790\u5668\u901a\u5e38\u4f1a\u901a\u8fc7\u79fb\u9664\u6811\u4e2d\u5927\u90e8\u5206\u201c\u4eba\u4e3a\u201d\u8282\u70b9\uff0c\u5c06\u89e3\u6790\u6811\u8f6c\u6362\u6210\u62bd\u8c61\u8bed\u6cd5\u6811\uff08\u53c8\u79f0AST\uff0c\u6216\u8005\u7b80\u79f0\u8bed\u6cd5\u6811\uff09\u3002\u8bed\u4e49\u5206\u6790\u5668\u8fd8\u4f1a\u4e3a\u5269\u4f59\u7684\u8282\u70b9\u6dfb\u52a0\u6709\u7528\u7684\u4fe1\u606f\uff0c\u6bd4\u5982\u4ece\u6807\u8bc6\u7b26\u5230\u5b83\u4eec\u7684\u7b26\u53f7\u8868\u6761\u76ee\u7684\u6307\u9488\u3002\u9644\u52a0\u5230\u7279\u5b9a\u8282\u70b9\u7684\u6ce8\u91ca\u88ab\u79f0\u4e3a\u5b83\u7684\u5c5e\u6027\u3002\u6211\u4eec\u7684\u6700\u5927\u516c\u7ea6\u6570\u7a0b\u5e8f\u7684\u8bed\u6cd5\u6811\u5982\u56fe1.5\u6240\u793a\u3002\\n\\nIn many compilers,the annotated syntax tree constitutes the intermediate form that is passed from the front end to the back end. In other compilers, semantic analysis ends with a traversal of the tree that generates some other intermediate form. One common such form consists of a control flow graph whose nodes resemble fragments of assembly language for a simple idealized machine. We will consider this option further in Chapter 14, where a control flow graph for our GCD program appears in Figure 14.3. In a suite of related compilers, the front ends for several languages and the back ends for several machines would share a common intermediate form.\\n\\n> \u5728\u8bb8\u591a\u7f16\u8bd1\u5668\u4e2d\uff0c\u5e26\u6ce8\u91ca\u7684\u8bed\u6cd5\u6811\u6784\u6210\u4e86\u4ece\u524d\u7aef\u4f20\u9012\u5230\u540e\u7aef\u7684\u4e2d\u95f4\u5f62\u5f0f\u3002\u5728\u5176\u4ed6\u7f16\u8bd1\u5668\u4e2d\uff0c\u8bed\u4e49\u5206\u6790\u4ee5\u904d\u5386\u751f\u6210\u67d0\u4e9b\u5176\u4ed6\u4e2d\u95f4\u5f62\u5f0f\u7684\u6811\u800c\u7ed3\u675f\u3002\u4e00\u79cd\u5e38\u89c1\u7684\u8fd9\u79cd\u5f62\u5f0f\u5305\u62ec\u4e00\u4e2a\u63a7\u5236\u6d41\u56fe\uff0c\u5176\u8282\u70b9\u7c7b\u4f3c\u4e8e\u7b80\u5316\u7406\u60f3\u673a\u5668\u7684\u6c47\u7f16\u8bed\u8a00\u7247\u6bb5\u3002\u6211\u4eec\u5c06\u5728\u7b2c14\u7ae0\u8fdb\u4e00\u6b65\u63a2\u8ba8\u8fd9\u4e2a\u9009\u9879\uff0c\u5728\u90a3\u91cc\u6211\u4eec\u7684GCD\u7a0b\u5e8f\u7684\u63a7\u5236\u6d41\u56fe\u51fa\u73b0\u5728\u56fe14.3\u4e2d\u3002\u5728\u4e00\u5957\u76f8\u5173\u7684\u7f16\u8bd1\u5668\u4e2d\uff0c\u591a\u79cd\u8bed\u8a00\u7684\u524d\u7aef\u548c\u591a\u79cd\u673a\u5668\u7684\u540e\u7aef\u5c06\u5171\u4eab\u4e00\u4e2a\u901a\u7528\u7684\u4e2d\u95f4\u5f62\u5f0f\u3002\\n\\n### Target Code Generation\\nThe code generation phase of a compiler translates the intermediate form into the target language. Given the information contained in the syntax tree, generating correct code is usually not a difficult task (generating good code is harder, as we shall see in Section 1.6.4). To generate assembly or machine language, the code generator traverses the symbol table to assign locations to variables, and then traverses the intermediate representation of the program, generating loads and stores for variable references,interspersed with appropriate arithmetic operations, tests, and branches. Naive code for our GCD example appears in Figure 1.6, in x86 assembly language. It was generated automatically by a simple pedagogical compiler.\\n\\n> \u7f16\u8bd1\u5668\u7684\u4ee3\u7801\u751f\u6210\u9636\u6bb5\u5c06\u4e2d\u95f4\u5f62\u5f0f\u8f6c\u6362\u4e3a\u76ee\u6807\u8bed\u8a00\u3002\u6839\u636e\u8bed\u6cd5\u6811\u4e2d\u5305\u542b\u7684\u4fe1\u606f\uff0c\u751f\u6210\u6b63\u786e\u7684\u4ee3\u7801\u901a\u5e38\u5e76\u4e0d\u662f\u4e00\u9879\u56f0\u96be\u7684\u4efb\u52a1\uff08\u751f\u6210\u4f18\u79c0\u7684\u4ee3\u7801\u66f4\u96be\uff0c\u6b63\u5982\u6211\u4eec\u5c06\u57281.6.4\u8282\u4e2d\u770b\u5230\u7684\u90a3\u6837\uff09\u3002\u4e3a\u4e86\u751f\u6210\u6c47\u7f16\u6216\u673a\u5668\u8bed\u8a00\uff0c\u4ee3\u7801\u751f\u6210\u5668\u904d\u5386\u7b26\u53f7\u8868\u4ee5\u4e3a\u53d8\u91cf\u5206\u914d\u4f4d\u7f6e\uff0c\u7136\u540e\u904d\u5386\u7a0b\u5e8f\u7684\u4e2d\u95f4\u8868\u793a\uff0c\u751f\u6210\u53d8\u91cf\u5f15\u7528\u7684\u52a0\u8f7d\u548c\u5b58\u50a8\uff0c\u5e76\u7a7f\u63d2\u9002\u5f53\u7684\u7b97\u672f\u64cd\u4f5c\u3001\u6d4b\u8bd5\u548c\u8df3\u8f6c\u3002\u6211\u4eec\u7684GCD\u793a\u4f8b\u7684\u6734\u7d20\u4ee3\u7801\u51fa\u73b0\u5728\u56fe1.6\u4e2d\uff0c\u4f7f\u7528x86\u6c47\u7f16\u8bed\u8a00\u7f16\u5199\u3002\u8fd9\u662f\u7531\u4e00\u4e2a\u7b80\u5355\u7684\u6559\u5b66\u7f16\u8bd1\u5668\u81ea\u52a8\u751f\u6210\u7684\u3002\\n\\nThe assembly language mnemonics may appear a bit cryptic,but the comments on each line (not generated by the compiler!) should make the correspondence between Figures 1.5 and 1.6 generally apparent. A few hints: esp, ebp, eax, ebx, and edi are registers (special storage locations, limited in number, that can be accessed very quickly). -8(%ebp) refers to the memory location 8 bytes before the location whose address is in register ebp; in this program, ebp serves as a base from which we can find variables i and j. The argument to a subroutine call instruction is passed by pushing it onto a stack, for which esp is the top-of-stack pointer. The return value comes back in register eax. Arithmetic operations overwrite their second argument with the result of the operation.\\n\\n> \u8fd9\u4e9b\u6c47\u7f16\u8bed\u8a00\u52a9\u8bb0\u7b26\u53ef\u80fd\u770b\u8d77\u6765\u6709\u70b9\u6666\u6da9\uff0c\u4f46\u6bcf\u884c\u7684\u6ce8\u91ca\uff08\u5e76\u975e\u7531\u7f16\u8bd1\u5668\u751f\u6210\uff01\uff09\u5e94\u8be5\u80fd\u591f\u4f7f\u56fe1.5\u548c\u56fe1.6\u4e4b\u95f4\u7684\u5bf9\u5e94\u5173\u7cfb\u57fa\u672c\u4e0a\u663e\u800c\u6613\u89c1\u3002\u4e00\u4e9b\u63d0\u793a\uff1aesp\u3001ebp\u3001eax\u3001ebx\u548cedi\u662f\u5bc4\u5b58\u5668\uff08\u7279\u6b8a\u7684\u5b58\u50a8\u4f4d\u7f6e\uff0c\u6570\u91cf\u6709\u9650\uff0c\u53ef\u4ee5\u88ab\u975e\u5e38\u5feb\u901f\u5730\u8bbf\u95ee\uff09\u3002-8(%ebp)\u6307\u7684\u662f\u5728\u5bc4\u5b58\u5668ebp\u4e2d\u5b58\u50a8\u5730\u5740\u7684\u4f4d\u7f6e\u7684\u524d8\u4e2a\u5b57\u8282\u7684\u5185\u5b58\u4f4d\u7f6e\uff1b\u5728\u8fd9\u4e2a\u7a0b\u5e8f\u4e2d\uff0cebp\u7528\u4f5c\u57fa\u5740\uff0c\u6211\u4eec\u53ef\u4ee5\u4ece\u4e2d\u627e\u5230\u53d8\u91cfi\u548cj\u3002\u5bf9\u4e8e\u5b50\u7a0b\u5e8f\u8c03\u7528\u6307\u4ee4\uff0c\u53c2\u6570\u662f\u901a\u8fc7\u5c06\u5176\u63a8\u9001\u5230\u5806\u6808\u4e2d\u4f20\u9012\u7684\uff0cesp\u662f\u5806\u6808\u9876\u90e8\u6307\u9488\u3002\u8fd4\u56de\u503c\u5b58\u653e\u5728\u5bc4\u5b58\u5668eax\u4e2d\u3002\u7b97\u672f\u64cd\u4f5c\u4f1a\u7528\u64cd\u4f5c\u7684\u7ed3\u679c\u8986\u76d6\u5176\u7b2c\u4e8c\u4e2a\u53c2\u6570\u3002\\n\\nOften a code generator will save the symbol table for later use by a symbolic debugger, by including it in a nonexecutable part of the target code.\\n\\n> \u901a\u5e38\uff0c\u4ee3\u7801\u751f\u6210\u5668\u4f1a\u5c06\u7b26\u53f7\u8868\u4fdd\u5b58\u4e0b\u6765\uff0c\u4ee5\u4fbf\u5c06\u6765\u88ab\u7b26\u53f7\u8c03\u8bd5\u5668\u4f7f\u7528\uff0c\u65b9\u6cd5\u662f\u5c06\u5176\u5305\u542b\u5728\u76ee\u6807\u4ee3\u7801\u7684\u4e0d\u53ef\u6267\u884c\u90e8\u5206\u4e2d\u3002\\n\\n### Code Improvement\\nCode improvement is often referred to as optimization, though it seldom makes anything optimal in any absolute sense. It is an optional phase of compilation whose goal is to transform a program into a new version that computes the same result more efficiently\u2014more quickly or using less memory, or both.\\n\\n> \u4ee3\u7801\u6539\u8fdb\u901a\u5e38\u88ab\u79f0\u4e3a\u4f18\u5316\uff0c\u5c3d\u7ba1\u5728\u4efb\u4f55\u7edd\u5bf9\u610f\u4e49\u4e0a\u5b83\u5f88\u5c11\u4f7f\u4efb\u4f55\u4e1c\u897f\u90fd\u53d8\u5f97\u6700\u4f73\u3002\u5b83\u662f\u7f16\u8bd1\u7684\u4e00\u4e2a\u53ef\u9009\u9636\u6bb5\uff0c\u5176\u76ee\u6807\u662f\u5c06\u7a0b\u5e8f\u8f6c\u6362\u4e3a\u4e00\u4e2a\u8ba1\u7b97\u76f8\u540c\u7ed3\u679c\u7684\u66f4\u9ad8\u6548\u7248\u672c\u2014\u2014\u66f4\u5feb\u6216\u8005\u4f7f\u7528\u66f4\u5c11\u7684\u5185\u5b58\uff0c\u6216\u8005\u4e24\u8005\u517c\u800c\u6709\u4e4b\u3002\\n\\nSome improvements are machine independent. These can be performed as transformations onthe intermediate form. Other improvements require an understanding of the target machine (or of whatever will execute the program in the target language). These must be performed as transformations on the target program. Thus code improvement often appears as two additional phases of compilation, one immediately after semantic analysis and intermediate code generation, the other immediately after target code generation.\\n\\n> \u6709\u4e9b\u6539\u8fdb\u662f\u4e0e\u673a\u5668\u65e0\u5173\u7684\u3002\u8fd9\u4e9b\u53ef\u4ee5\u4f5c\u4e3a\u5bf9\u4e2d\u95f4\u5f62\u5f0f\u7684\u8f6c\u6362\u6765\u6267\u884c\u3002\u5176\u4ed6\u6539\u8fdb\u9700\u8981\u5bf9\u76ee\u6807\u673a\u5668\uff08\u6216\u8005\u5728\u76ee\u6807\u8bed\u8a00\u4e2d\u6267\u884c\u7a0b\u5e8f\u7684\u4efb\u4f55\u5185\u5bb9\uff09\u7684\u7406\u89e3\u3002\u8fd9\u4e9b\u5fc5\u987b\u4f5c\u4e3a\u5bf9\u76ee\u6807\u7a0b\u5e8f\u7684\u8f6c\u6362\u6765\u6267\u884c\u3002\u56e0\u6b64\uff0c\u4ee3\u7801\u6539\u8fdb\u901a\u5e38\u51fa\u73b0\u4e3a\u7f16\u8bd1\u7684\u4e24\u4e2a\u989d\u5916\u9636\u6bb5\uff0c\u4e00\u4e2a\u7d27\u8ddf\u8bed\u4e49\u5206\u6790\u548c\u4e2d\u95f4\u4ee3\u7801\u751f\u6210\u4e4b\u540e\uff0c\u53e6\u4e00\u4e2a\u7d27\u8ddf\u76ee\u6807\u4ee3\u7801\u751f\u6210\u4e4b\u540e\u3002\\n\\nApplying a good code improver to the code in Figure 1.6 produces the code shown in Example 1.2 (page 5). Comparing the two programs, we can see that the improved version is quite a lot shorter. Conspicuously absent are most of the loads and stores. The machine-independent code improver is able to verify that i and j can be kept in registers throughout the execution of the main loop. (This would not have been the case if,for example,the loop contained a call to a subroutine that might reuse those registers, or that might try to modify i or j.) The machine specific code improver is then able to assign i and j to actual registers of the target machine. For modern microprocessor architectures, particularly those with so-called superscalar implementations (ones in which separate functional units can execute instructions simultaneously), compilers can usually generate better code than can human assembly language programmers.\\n\\n> \u5c06\u56fe1.6\u4e2d\u7684\u4ee3\u7801\u5e94\u7528\u4e8e\u826f\u597d\u7684\u4ee3\u7801\u6539\u8fdb\u5668\u4f1a\u4ea7\u751f\u793a\u4f8b1.2\uff08\u7b2c5\u9875\uff09\u4e2d\u6240\u793a\u7684\u4ee3\u7801\u3002\u6bd4\u8f83\u8fd9\u4e24\u4e2a\u7a0b\u5e8f\uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u6539\u8fdb\u540e\u7684\u7248\u672c\u8981\u77ed\u5f97\u591a\u3002\u660e\u663e\u7f3a\u5931\u7684\u662f\u5927\u90e8\u5206\u7684\u52a0\u8f7d\u548c\u5b58\u50a8\u64cd\u4f5c\u3002\u673a\u5668\u65e0\u5173\u7684\u4ee3\u7801\u6539\u8fdb\u5668\u80fd\u591f\u9a8c\u8bc1\u5728\u4e3b\u5faa\u73af\u7684\u6267\u884c\u8fc7\u7a0b\u4e2d\uff0ci\u548cj\u53ef\u4ee5\u4e00\u76f4\u4fdd\u6301\u5728\u5bc4\u5b58\u5668\u4e2d\u3002\uff08\u5982\u679c\uff0c\u4f8b\u5982\uff0c\u5faa\u73af\u4e2d\u5305\u542b\u5bf9\u5b50\u7a0b\u5e8f\u7684\u8c03\u7528\uff0c\u8be5\u5b50\u7a0b\u5e8f\u53ef\u80fd\u4f1a\u91cd\u7528\u8fd9\u4e9b\u5bc4\u5b58\u5668\uff0c\u6216\u8005\u53ef\u80fd\u8bd5\u56fe\u4fee\u6539i\u6216j\uff0c\u90a3\u4e48\u60c5\u51b5\u5c31\u4e0d\u540c\u4e86\u3002\uff09\u7136\u540e\uff0c\u7279\u5b9a\u4e8e\u673a\u5668\u7684\u4ee3\u7801\u6539\u8fdb\u5668\u80fd\u591f\u5c06i\u548cj\u5206\u914d\u7ed9\u76ee\u6807\u673a\u5668\u7684\u5b9e\u9645\u5bc4\u5b58\u5668\u3002\u5bf9\u4e8e\u73b0\u4ee3\u5fae\u5904\u7406\u5668\u67b6\u6784\uff0c\u7279\u522b\u662f\u90a3\u4e9b\u5177\u6709\u6240\u8c13\u7684\u8d85\u6807\u91cf\u5b9e\u73b0\uff08\u53ef\u4ee5\u540c\u65f6\u6267\u884c\u6307\u4ee4\u7684\u72ec\u7acb\u529f\u80fd\u5355\u5143\uff09\uff0c\u7f16\u8bd1\u5668\u901a\u5e38\u80fd\u591f\u751f\u6210\u6bd4\u4eba\u7c7b\u6c47\u7f16\u8bed\u8a00\u7a0b\u5e8f\u5458\u66f4\u597d\u7684\u4ee3\u7801\u3002\\n\\n### Summary and Concluding Remarks\\nIn this chapter we introduced the study of programming language design and implementation. We considered why there are so many languages, what makes them successful or unsuccessful, how they may be categorized for study, and what benefits the reader is likely to gain from that study. We noted that language design and language implementation are intimately related to one another. Obviously an implementation must conform to the rules of the language. At the same time, a language designer must consider how easy or difficult it will be to implement various features, and what sort of performance is likely to result for programs that use those features.\\n\\n> \u5728\u672c\u7ae0\u4e2d\uff0c\u6211\u4eec\u4ecb\u7ecd\u4e86\u7f16\u7a0b\u8bed\u8a00\u8bbe\u8ba1\u548c\u5b9e\u73b0\u7684\u7814\u7a76\u3002\u6211\u4eec\u8003\u8651\u4e86\u4e3a\u4ec0\u4e48\u4f1a\u6709\u8fd9\u4e48\u591a\u79cd\u8bed\u8a00\uff0c\u662f\u4ec0\u4e48\u8ba9\u5b83\u4eec\u6210\u529f\u6216\u5931\u8d25\uff0c\u5b83\u4eec\u53ef\u4ee5\u5982\u4f55\u5206\u7c7b\u8fdb\u884c\u7814\u7a76\uff0c\u4ee5\u53ca\u8bfb\u8005\u53ef\u80fd\u4ece\u8fd9\u4e9b\u7814\u7a76\u4e2d\u83b7\u5f97\u4ec0\u4e48\u597d\u5904\u3002\u6211\u4eec\u6307\u51fa\u8bed\u8a00\u8bbe\u8ba1\u548c\u8bed\u8a00\u5b9e\u73b0\u4e4b\u95f4\u5bc6\u5207\u76f8\u5173\u3002\u663e\u7136\uff0c\u5b9e\u73b0\u5fc5\u987b\u7b26\u5408\u8bed\u8a00\u7684\u89c4\u5219\u3002\u540c\u65f6\uff0c\u8bed\u8a00\u8bbe\u8ba1\u8005\u5fc5\u987b\u8003\u8651\u5b9e\u73b0\u5404\u79cd\u7279\u6027\u7684\u96be\u6613\u7a0b\u5ea6\uff0c\u4ee5\u53ca\u4f7f\u7528\u8fd9\u4e9b\u7279\u6027\u7684\u7a0b\u5e8f\u53ef\u80fd\u4f1a\u4ea7\u751f\u600e\u6837\u7684\u6027\u80fd\u3002\\n\\nLanguage implementations are commonly differentiated into those based on interpretation and those based on compilation. We noted, however, that the difference between these approaches is fuzzy,and that most implementations include a bit of each. As a general rule, we say that a language is compiled if execution is preceded by a translation step that (1) fully analyzes both the structure (syntax) and meaning (semantics) of the program, and (2) produces an equivalent program in a significantly different form. The bulk of the implementation material in this book pertains to compilation.\\n\\n> \u7f16\u7a0b\u8bed\u8a00\u7684\u5b9e\u73b0\u901a\u5e38\u5206\u4e3a\u57fa\u4e8e\u89e3\u91ca\u548c\u57fa\u4e8e\u7f16\u8bd1\u7684\u4e24\u79cd\u7c7b\u578b\u3002\u7136\u800c\uff0c\u6211\u4eec\u6307\u51fa\u8fd9\u4e24\u79cd\u65b9\u6cd5\u4e4b\u95f4\u7684\u533a\u522b\u662f\u6a21\u7cca\u7684\uff0c\u5e76\u4e14\u5927\u591a\u6570\u5b9e\u73b0\u90fd\u5305\u542b\u4e86\u4e24\u8005\u7684\u4e00\u4e9b\u7279\u70b9\u3002\u4e00\u822c\u800c\u8a00\uff0c\u6211\u4eec\u8bf4\u4e00\u79cd\u8bed\u8a00\u662f\u7f16\u8bd1\u578b\u7684\uff0c\u5982\u679c\u5728\u6267\u884c\u4e4b\u524d\u9700\u8981\u7ecf\u8fc7\u4e00\u4e2a\u7ffb\u8bd1\u6b65\u9aa4\uff0c\u8fd9\u4e2a\u6b65\u9aa4\u4f1a\uff081\uff09\u5b8c\u5168\u5206\u6790\u7a0b\u5e8f\u7684\u7ed3\u6784\uff08\u8bed\u6cd5\uff09\u548c\u542b\u4e49\uff08\u8bed\u4e49\uff09\uff0c\u4ee5\u53ca\uff082\uff09\u751f\u6210\u4e00\u4e2a\u5728\u5f62\u5f0f\u4e0a\u660e\u663e\u4e0d\u540c\u7684\u7b49\u6548\u7a0b\u5e8f\u3002\u672c\u4e66\u4e2d\u5927\u90e8\u5206\u7684\u5b9e\u73b0\u5185\u5bb9\u6d89\u53ca\u7f16\u8bd1\u3002\\n\\nCompilers are generally structured as a series of phases. The first few phases scanning, parsing, and semantic analysis\u2014serve to analyze the source program. Collectively these phases are known as the compiler\u2019s front end. The final few phases\u2014intermediate code generation, code improvement, and target code generation\u2014are known as the back end. They serve to build a target program preferably a fast one\u2014whose semantics match those of the source.\\n\\n> \u7f16\u8bd1\u5668\u901a\u5e38\u88ab\u6784\u5efa\u4e3a\u4e00\u7cfb\u5217\u9636\u6bb5\u3002\u6700\u521d\u7684\u51e0\u4e2a\u9636\u6bb5\u2014\u2014\u626b\u63cf\u3001\u89e3\u6790\u548c\u8bed\u4e49\u5206\u6790\u2014\u2014\u7528\u4e8e\u5206\u6790\u6e90\u7a0b\u5e8f\u3002\u8fd9\u4e9b\u9636\u6bb5\u7edf\u79f0\u4e3a\u7f16\u8bd1\u5668\u7684\u524d\u7aef\u3002\u6700\u540e\u7684\u51e0\u4e2a\u9636\u6bb5\u2014\u2014\u4e2d\u95f4\u4ee3\u7801\u751f\u6210\u3001\u4ee3\u7801\u4f18\u5316\u548c\u76ee\u6807\u4ee3\u7801\u751f\u6210\u2014\u2014\u88ab\u79f0\u4e3a\u540e\u7aef\u3002\u5b83\u4eec\u7528\u4e8e\u6784\u5efa\u76ee\u6807\u7a0b\u5e8f\u2014\u2014\u6700\u597d\u662f\u4e00\u4e2a\u8bed\u4e49\u4e0e\u6e90\u7a0b\u5e8f\u76f8\u5339\u914d\u4e14\u5feb\u901f\u7684\u7a0b\u5e8f\u3002\\n\\nChapters 3,6,7,8,and 9 form the core of the rest of this book. They cover fundamental issues of language design, both from the point of view of the programmer and from the point of view of the language implementor. To support the discussion of implementations, Chapters 2 and 4 describe compiler front ends in more detail than has been possible in this introduction. Chapter 5 provides an overview of assembly-level architecture. Chapters 14 through 16 discuss compiler back ends, including assemblers and linkers, run-time systems, and code improvement techniques. Additional language paradigms are covered in Chapters 10 through 13. Appendix A lists the principal programming languages mentioned in the text, together with a genealogical chart and bibliographic references. Appendix B contains a list of \u201cDesign & Implementation\u201d sidebars; Appendix C contains a list of numbered examples.\\n\\n> \u7b2c3\u30016\u30017\u30018\u548c9\u7ae0\u6784\u6210\u4e86\u672c\u4e66\u7684\u6838\u5fc3\u90e8\u5206\u3002\u5b83\u4eec\u6db5\u76d6\u4e86\u8bed\u8a00\u8bbe\u8ba1\u7684\u57fa\u672c\u95ee\u9898\uff0c\u65e2\u4ece\u7a0b\u5e8f\u5458\u7684\u89d2\u5ea6\uff0c\u4e5f\u4ece\u8bed\u8a00\u5b9e\u73b0\u8005\u7684\u89d2\u5ea6\u8fdb\u884c\u4e86\u8ba8\u8bba\u3002\u4e3a\u4e86\u652f\u6301\u5bf9\u5b9e\u73b0\u7684\u8ba8\u8bba\uff0c\u7b2c2\u7ae0\u548c\u7b2c4\u7ae0\u6bd4\u672c\u4ecb\u7ecd\u90e8\u5206\u66f4\u8be6\u7ec6\u5730\u63cf\u8ff0\u4e86\u7f16\u8bd1\u5668\u7684\u524d\u7aef\u3002\u7b2c5\u7ae0\u6982\u8ff0\u4e86\u6c47\u7f16\u7ea7\u67b6\u6784\u3002\u7b2c14\u81f316\u7ae0\u8ba8\u8bba\u4e86\u7f16\u8bd1\u5668\u7684\u540e\u7aef\uff0c\u5305\u62ec\u6c47\u7f16\u5668\u548c\u94fe\u63a5\u5668\u3001\u8fd0\u884c\u65f6\u7cfb\u7edf\u4ee5\u53ca\u4ee3\u7801\u4f18\u5316\u6280\u672f\u3002\u7b2c10\u81f313\u7ae0\u6db5\u76d6\u4e86\u989d\u5916\u7684\u8bed\u8a00\u8303\u5f0f\u3002\u9644\u5f55A\u5217\u51fa\u4e86\u6587\u672c\u4e2d\u63d0\u5230\u7684\u4e3b\u8981\u7f16\u7a0b\u8bed\u8a00\uff0c\u4ee5\u53ca\u5b83\u4eec\u7684\u8c31\u7cfb\u56fe\u548c\u53c2\u8003\u6587\u732e\u3002\u9644\u5f55B\u5305\u542b\u4e86\u201c\u8bbe\u8ba1\u4e0e\u5b9e\u73b0\u201d\u65b9\u5757\u7684\u5217\u8868\uff1b\u9644\u5f55C\u5305\u542b\u4e86\u7f16\u53f7\u793a\u4f8b\u7684\u5217\u8868\u3002"}]}}')}}]);