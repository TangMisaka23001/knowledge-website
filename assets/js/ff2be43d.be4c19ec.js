"use strict";(self.webpackChunkmy_knowledge_repo=self.webpackChunkmy_knowledge_repo||[]).push([[8169],{5872:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var a=n(5893),i=n(1151);const s={title:"Programming Language Pragmatics \u7b2c\u4e00\u7ae0\u7b14\u8bb0\u4e0b",tags:["\u7f16\u8bd1\u5668","Programming Language Pragmatics"]},r=void 0,o={permalink:"/blog/2024/programming-language-pragmatics-02",source:"@site/blog/2024/programming-language-pragmatics-02.md",title:"Programming Language Pragmatics \u7b2c\u4e00\u7ae0\u7b14\u8bb0\u4e0b",description:"An Overview of Compilation",date:"2024-01-25T08:06:02.000Z",tags:[{inline:!0,label:"\u7f16\u8bd1\u5668",permalink:"/blog/tags/\u7f16\u8bd1\u5668"},{inline:!0,label:"Programming Language Pragmatics",permalink:"/blog/tags/programming-language-pragmatics"}],readingTime:31.75,hasTruncateMarker:!1,authors:[],frontMatter:{title:"Programming Language Pragmatics \u7b2c\u4e00\u7ae0\u7b14\u8bb0\u4e0b",tags:["\u7f16\u8bd1\u5668","Programming Language Pragmatics"]},unlisted:!1,prevItem:{title:"Programming Language Pragmatics \u7b2c\u4e00\u7ae0\u7b14\u8bb0\u4e0a",permalink:"/blog/2024/programming-language-pragmatics-01"}},l={authorsImageUrls:[]},c=[{value:"An Overview of Compilation",id:"an-overview-of-compilation",level:2},{value:"Lexical and Syntax Analysis",id:"lexical-and-syntax-analysis",level:3},{value:"Semantic Analysis and Intermediate Code Generation",id:"semantic-analysis-and-intermediate-code-generation",level:3},{value:"Target Code Generation",id:"target-code-generation",level:3},{value:"Code Improvement",id:"code-improvement",level:3},{value:"Summary and Concluding Remarks",id:"summary-and-concluding-remarks",level:3}];function h(e){const t={blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h2,{id:"an-overview-of-compilation",children:"An Overview of Compilation"}),"\n",(0,a.jsx)(t.p,{children:"Compilers are among the most well-studied classes of computer programs. We will consider them repeatedly throughout the rest of the book, and in Chapters 2, 4, 14, and 16 in particular. The remainder of this section provides an introductory overview."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\u7f16\u8bd1\u5668\u662f\u6700\u53d7\u4eba\u7814\u7a76\u7684\u8ba1\u7b97\u673a\u7a0b\u5e8f\u7c7b\u522b\u4e4b\u4e00\u3002\u6211\u4eec\u5c06\u5728\u672c\u4e66\u7684\u5176\u4f59\u90e8\u5206\u591a\u6b21\u8003\u8651\u5b83\u4eec\uff0c\u7279\u522b\u662f\u5728\u7b2c2\u30014\u300114\u548c16\u7ae0\u3002\u672c\u8282\u7684\u5176\u4f59\u90e8\u5206\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7b80\u8981\u6982\u8ff0\u3002"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{src:"https://misakatang.oss-cn-beijing.aliyuncs.com/blog_picture/Snipaste_2023-11-15_15-40-01.png",alt:""})}),"\n",(0,a.jsx)(t.p,{children:"In a typical compiler, compilation proceeds through a series of well-defined phases, shown in Figure 1.3. Each phase discovers information of use to later phases, or transforms the program into a form that is more useful to the subsequent phase."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\u5728\u5178\u578b\u7684\u7f16\u8bd1\u5668\u4e2d\uff0c\u7f16\u8bd1\u8fc7\u7a0b\u7ecf\u8fc7\u4e00\u7cfb\u5217\u660e\u786e\u5b9a\u4e49\u7684\u9636\u6bb5\uff0c\u5982\u56fe1.3\u6240\u793a\u3002\u6bcf\u4e2a\u9636\u6bb5\u90fd\u4f1a\u53d1\u73b0\u5bf9\u540e\u7eed\u9636\u6bb5\u6709\u7528\u7684\u4fe1\u606f\uff0c\u6216\u5c06\u7a0b\u5e8f\u8f6c\u6362\u4e3a\u5bf9\u540e\u7eed\u9636\u6bb5\u66f4\u6709\u7528\u7684\u5f62\u5f0f\u3002"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"The first few phases (up through semantic analysis) serve to figure out the meaning of the source program. They are sometimes called the front end of the compiler. The last few phases serve to construct an equivalent target program. They are sometimes called the back end of the compiler. Many compiler phases can be created automatically from a formal description of the source and/or target languages."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\u524d\u51e0\u4e2a\u9636\u6bb5\uff08\u76f4\u5230\u8bed\u4e49\u5206\u6790\uff09\u7528\u4e8e\u5f04\u6e05\u6e90\u7a0b\u5e8f\u7684\u542b\u4e49\u3002\u5b83\u4eec\u6709\u65f6\u88ab\u79f0\u4e3a\u7f16\u8bd1\u5668\u7684\u524d\u7aef\u3002\u6700\u540e\u51e0\u4e2a\u9636\u6bb5\u7528\u4e8e\u6784\u5efa\u4e00\u4e2a\u7b49\u4ef7\u7684\u76ee\u6807\u7a0b\u5e8f\u3002\u5b83\u4eec\u6709\u65f6\u88ab\u79f0\u4e3a\u7f16\u8bd1\u5668\u7684\u540e\u7aef\u3002\u8bb8\u591a\u7f16\u8bd1\u5668\u9636\u6bb5\u53ef\u4ee5\u6839\u636e\u6e90\u8bed\u8a00\u548c/\u6216\u76ee\u6807\u8bed\u8a00\u7684\u5f62\u5f0f\u5316\u63cf\u8ff0\u81ea\u52a8\u751f\u6210\u3002"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"One will sometimes hear compilation described as a series of passes. A pass is a phase or set of phases that is serialized with respect to the rest of compilation: it does not start until previous phases have completed, and it finishes before any subsequent phases start. If desired, a pass may be written as a separate program, reading its input from a file and writing its output to a file. Compilers are commonly divided into passes so that the front end may be shared by compilers for more than one machine (target language), and so that the back end may be shared by compilers for more than one source language. In some implementations the front end and the back end may be separated by a\u201cmiddle end\u201dthat is responsible for language- and machine-independent code improvement. Prior to the dramatic increases in memory sizes of the mid to late 1980s, compilers were also sometimes divided into passes to minimize memory usage: as each pass completed, the next could reuse its code space."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\u6709\u65f6\u4f1a\u542c\u5230\u5c06\u7f16\u8bd1\u63cf\u8ff0\u4e3a\u4e00\u7cfb\u5217\u4f20\u9012\u3002\u4f20\u9012\u662f\u4e00\u4e2a\u76f8\u5bf9\u4e8e\u7f16\u8bd1\u7684\u5176\u4f59\u90e8\u5206\u8fdb\u884c\u4e32\u884c\u5316\u7684\u9636\u6bb5\u6216\u4e00\u7ec4\u9636\u6bb5\uff1a\u5b83\u5728\u524d\u4e00\u9636\u6bb5\u5b8c\u6210\u4e4b\u524d\u4e0d\u4f1a\u5f00\u59cb\uff0c\u5e76\u4e14\u5728\u4efb\u4f55\u540e\u7eed\u9636\u6bb5\u5f00\u59cb\u4e4b\u524d\u5c31\u4f1a\u7ed3\u675f\u3002\u5982\u679c\u9700\u8981\uff0c\u53ef\u4ee5\u5c06\u4f20\u9012\u7f16\u5199\u4e3a\u4e00\u4e2a\u72ec\u7acb\u7684\u7a0b\u5e8f\uff0c\u4ece\u6587\u4ef6\u8bfb\u53d6\u8f93\u5165\u5e76\u5c06\u8f93\u51fa\u5199\u5165\u6587\u4ef6\u3002\u7f16\u8bd1\u5668\u901a\u5e38\u88ab\u5212\u5206\u4e3a\u4f20\u9012\uff0c\u4ee5\u4fbf\u524d\u7aef\u53ef\u4ee5\u88ab\u591a\u53f0\u673a\u5668\uff08\u76ee\u6807\u8bed\u8a00\uff09\u7684\u7f16\u8bd1\u5668\u5171\u4eab\uff0c\u540e\u7aef\u53ef\u4ee5\u88ab\u591a\u79cd\u6e90\u8bed\u8a00\u7684\u7f16\u8bd1\u5668\u5171\u4eab\u3002\u5728\u4e00\u4e9b\u5b9e\u73b0\u4e2d\uff0c\u524d\u7aef\u548c\u540e\u7aef\u53ef\u80fd\u88ab\u4e00\u4e2a\u8d1f\u8d23\u8bed\u8a00\u548c\u673a\u5668\u65e0\u5173\u4ee3\u7801\u6539\u8fdb\u7684\u201c\u4e2d\u7aef\u201d\u5206\u5f00\u3002\u572820\u4e16\u7eaa80\u5e74\u4ee3\u4e2d\u671f\u5230\u665a\u671f\u5185\u5b58\u5927\u5c0f\u5927\u5e45\u589e\u52a0\u4e4b\u524d\uff0c\u6709\u65f6\u4e5f\u5c06\u7f16\u8bd1\u5668\u5212\u5206\u4e3a\u4f20\u9012\u4ee5\u6700\u5c0f\u5316\u5185\u5b58\u4f7f\u7528\uff1a\u5f53\u6bcf\u4e2a\u4f20\u9012\u5b8c\u6210\u65f6\uff0c\u4e0b\u4e00\u4e2a\u4f20\u9012\u53ef\u4ee5\u91cd\u7528\u5176\u4ee3\u7801\u7a7a\u95f4\u3002"}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"lexical-and-syntax-analysis",children:"Lexical and Syntax Analysis"}),"\n",(0,a.jsx)(t.p,{children:"Scanning is also known as lexical analysis. The principal purpose of the scanner is to simplify the task of the parser, by reducing the size of the input (there are many more characters than tokens) and by removing extraneous characters like white space. The scanner also typically removes comments and tags tokens with line and column numbers, to make it easier to generate good diagnostics in later phases. One could design a parser to take characters instead of tokens as inputdispensing with the scanner\u2014but the result would be awkward and slow."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\u626b\u63cf\u4e5f\u88ab\u79f0\u4e3a\u8bcd\u6cd5\u5206\u6790\u3002\u626b\u63cf\u5668\u7684\u4e3b\u8981\u76ee\u7684\u662f\u7b80\u5316\u89e3\u6790\u5668\u7684\u4efb\u52a1\uff0c\u901a\u8fc7\u51cf\u5c11\u8f93\u5165\u7684\u5927\u5c0f\uff08\u5b57\u7b26\u6bd4\u6807\u8bb0\u8981\u591a\u5f97\u591a\uff09\uff0c\u5e76\u5220\u9664\u591a\u4f59\u7684\u5b57\u7b26\uff0c\u5982\u7a7a\u767d\u3002\u626b\u63cf\u5668\u901a\u5e38\u8fd8\u4f1a\u79fb\u9664\u6ce8\u91ca\uff0c\u5e76\u4e3a\u6807\u8bb0\u6dfb\u52a0\u884c\u53f7\u548c\u5217\u53f7\uff0c\u4ee5\u4fbf\u5728\u540e\u7eed\u9636\u6bb5\u66f4\u5bb9\u6613\u751f\u6210\u826f\u597d\u7684\u8bca\u65ad\u4fe1\u606f\u3002\u7406\u8bba\u4e0a\u53ef\u4ee5\u8bbe\u8ba1\u4e00\u4e2a\u89e3\u6790\u5668\uff0c\u63a5\u53d7\u5b57\u7b26\u800c\u4e0d\u662f\u6807\u8bb0\u4f5c\u4e3a\u8f93\u5165\uff0c\u4ece\u800c\u7701\u53bb\u626b\u63cf\u5668\uff0c\u4f46\u7ed3\u679c\u4f1a\u5f88\u7b28\u62d9\u4e14\u6548\u7387\u4f4e\u4e0b\u3002"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Parsing organizes tokens into a parse tree that represents higher-level constructs (statements, expressions, subroutines, and so on) in terms of their constituents. Each construct is a node in the tree; its constituents are its children. The root ofthe tree is simply \u201cprogram\u201d; the leaves, from left to right, are the tokens received from the scanner. Taken as a whole, the tree shows how the tokens fit together to make a valid program. The structure relies on a set of potentially recursive rules known as a context-free grammar. Each rule has an arrow sign (\u2212\u2192) with the construct name on the left and a possible expansion on the right. In C, for example, a while loop consists of the keyword while followed by a parenthesized Boolean expression and a statement:"}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\u89e3\u6790\u5c06\u6807\u8bb0\u7ec4\u7ec7\u6210\u4e00\u4e2a\u89e3\u6790\u6811\uff0c\u8be5\u6811\u4ee5\u5176\u7ec4\u6210\u90e8\u5206\u8868\u793a\u9ad8\u7ea7\u6784\u9020\uff08\u8bed\u53e5\u3001\u8868\u8fbe\u5f0f\u3001\u5b50\u7a0b\u5e8f\u7b49\uff09\u3002\u6bcf\u4e2a\u6784\u9020\u90fd\u662f\u6811\u4e2d\u7684\u4e00\u4e2a\u8282\u70b9\uff1b\u5b83\u7684\u7ec4\u6210\u90e8\u5206\u662f\u5b83\u7684\u5b50\u8282\u70b9\u3002\u6811\u7684\u6839\u8282\u70b9\u7b80\u5355\u5730\u662f\u201c\u7a0b\u5e8f\u201d\uff1b\u4ece\u5de6\u5230\u53f3\u7684\u53f6\u5b50\u8282\u70b9\u662f\u6765\u81ea\u626b\u63cf\u5668\u7684\u6807\u8bb0\u3002\u6574\u4f53\u4e0a\u770b\uff0c\u6811\u663e\u793a\u4e86\u6807\u8bb0\u5982\u4f55\u7ec4\u5408\u5728\u4e00\u8d77\u5f62\u6210\u4e00\u4e2a\u6709\u6548\u7684\u7a0b\u5e8f\u3002\u8be5\u7ed3\u6784\u4f9d\u8d56\u4e8e\u4e00\u7ec4\u6f5c\u5728\u9012\u5f52\u7684\u89c4\u5219\uff0c\u79f0\u4e3a\u65e0\u4e0a\u4e0b\u6587\u8bed\u6cd5\u3002\u6bcf\u4e2a\u89c4\u5219\u90fd\u6709\u4e00\u4e2a\u7bad\u5934\u7b26\u53f7\uff08\u2192\uff09\uff0c\u5de6\u8fb9\u662f\u6784\u9020\u540d\u79f0\uff0c\u53f3\u8fb9\u662f\u53ef\u80fd\u7684\u6269\u5c55\u3002\u4f8b\u5982\uff0c\u5728C\u8bed\u8a00\u4e2d\uff0cwhile\u5faa\u73af\u7531\u5173\u952e\u5b57while\u540e\u8ddf\u62ec\u53f7\u4e2d\u7684\u5e03\u5c14\u8868\u8fbe\u5f0f\u548c\u4e00\u4e2a\u8bed\u53e5\u7ec4\u6210\uff1a"}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"iteration-statement \u2212\u2192 while ( expression ) statement\n"})}),"\n",(0,a.jsx)(t.p,{children:"The statement, in turn, is often a list enclosed in braces:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"statement \u2212\u2192 compound-statement\ncompound-statement \u2212\u2192 { block-item-list opt }\n"})}),"\n",(0,a.jsx)(t.p,{children:"where"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"block-item-list opt \u2212\u2192 block-item-list\n"})}),"\n",(0,a.jsx)(t.p,{children:"or"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"block-item-list opt \u2212\u2192 \u03f5\n"})}),"\n",(0,a.jsx)(t.p,{children:"and"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"block-item-list \u2212\u2192 block-item\nblock-item-list \u2212\u2192 block-item-list block-item\nblock-item \u2212\u2192 declaration\nblock-item \u2212\u2192 statement\n"})}),"\n",(0,a.jsx)(t.p,{children:"Here \u03f5 represents the empty string; it indicates that block-item-list opt can simply be deleted. Many more grammar rules are needed, of course, to explain the full structure of a program."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\u8fd9\u91cc\u7684 \u03f5 \u4ee3\u8868\u7a7a\u5b57\u7b26\u4e32\uff1b\u5b83\u8868\u793a block-item-list opt \u53ef\u4ee5\u88ab\u7b80\u5355\u5730\u5220\u9664\u3002\u5f53\u7136\uff0c\u9700\u8981\u66f4\u591a\u7684\u8bed\u6cd5\u89c4\u5219\u6765\u89e3\u91ca\u7a0b\u5e8f\u7684\u5b8c\u6574\u7ed3\u6784\u3002"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"A context-free grammar is said to define the syntax of the language; parsing is therefore known as syntax analysis. There are many possible grammars for C (an infinite number, in fact); the fragment shown above is taken from the sample grammar contained in the official language definition [Int99]. A full parse tree for our GCD program (based on a full grammar not shown here) appears in Figure 1.4. While the size of the tree may seem daunting, its details aren\u2019t particularly important at this point in the text. What is important is that (1) each individual branching point represents the application of a single grammar rule, and (2) the resulting complexity is more a reflection of the grammar than it is of the input program. Much of it stems from (a) the use of such artificial \u201cconstructs\u201d as block item-list and block item-list opt to generate lists of arbitrary length, and (b) the use of the equally artificial assignment-expression, additive expression, multiplicative-expression, and so on, to capture precedence and associativity in arithmetic expressions. We shall see in the following subsection that much of this complexity can be discarded once parsing is complete."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\u4e00\u4e2a\u65e0\u4e0a\u4e0b\u6587\u8bed\u6cd5\u88ab\u8ba4\u4e3a\u5b9a\u4e49\u4e86\u8bed\u8a00\u7684\u8bed\u6cd5\uff1b\u56e0\u6b64\uff0c\u89e3\u6790\u4e5f\u88ab\u79f0\u4e3a\u8bed\u6cd5\u5206\u6790\u3002\u5bf9\u4e8eC\u8bed\u8a00\u6709\u8bb8\u591a\u53ef\u80fd\u7684\u8bed\u6cd5\uff08\u5b9e\u9645\u4e0a\u662f\u65e0\u9650\u591a\u4e2a\uff09\uff1b\u4e0a\u9762\u663e\u793a\u7684\u7247\u6bb5\u53d6\u81ea\u5b98\u65b9\u8bed\u8a00\u5b9a\u4e49\u4e2d\u5305\u542b\u7684\u6837\u4f8b\u8bed\u6cd5[Int99]\u3002\u57fa\u4e8e\u672a\u5728\u6b64\u5904\u663e\u793a\u7684\u5b8c\u6574\u8bed\u6cd5\u7684\u6211\u4eec\u7684GCD\u7a0b\u5e8f\u7684\u5b8c\u6574\u89e3\u6790\u6811\u663e\u793a\u5728\u56fe1.4\u4e2d\u3002\u867d\u7136\u6811\u7684\u5927\u5c0f\u53ef\u80fd\u770b\u8d77\u6765\u4ee4\u4eba\u751f\u754f\uff0c\u4f46\u5728\u672c\u6587\u7684\u8fd9\u4e00\u9636\u6bb5\uff0c\u5176\u7ec6\u8282\u5e76\u4e0d\u7279\u522b\u91cd\u8981\u3002\u91cd\u8981\u7684\u662f\uff1a\uff081\uff09\u6bcf\u4e2a\u5355\u72ec\u7684\u5206\u652f\u70b9\u4ee3\u8868\u4e00\u4e2a\u5355\u4e00\u7684\u8bed\u6cd5\u89c4\u5219\u7684\u5e94\u7528\uff0c\u4ee5\u53ca\uff082\uff09\u4ea7\u751f\u7684\u590d\u6742\u6027\u66f4\u591a\u5730\u53cd\u6620\u4e86\u8bed\u6cd5\u800c\u4e0d\u662f\u8f93\u5165\u7a0b\u5e8f\u672c\u8eab\u3002\u5176\u4e2d\u8bb8\u591a\u590d\u6742\u6027\u6e90\u81ea\u4e8e\uff08a\uff09\u4f7f\u7528\u8bf8\u5982 block item-list \u548c block item-list opt \u4e4b\u7c7b\u7684\u4eba\u4e3a\u201c\u6784\u9020\u201d\u6765\u751f\u6210\u4efb\u610f\u957f\u5ea6\u7684\u5217\u8868\uff0c\u4ee5\u53ca\uff08b\uff09\u4f7f\u7528\u540c\u6837\u4eba\u4e3a\u7684 assignment-expression\u3001additive-expression\u3001multiplicative-expression \u7b49\u6765\u6355\u83b7\u7b97\u672f\u8868\u8fbe\u5f0f\u4e2d\u7684\u4f18\u5148\u7ea7\u548c\u7ed3\u5408\u6027\u3002\u5728\u63a5\u4e0b\u6765\u7684\u5c0f\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u770b\u5230\u4e00\u65e6\u89e3\u6790\u5b8c\u6210\uff0c\u8bb8\u591a\u8fd9\u4e9b\u590d\u6742\u6027\u90fd\u53ef\u4ee5\u88ab\u4e22\u5f03\u3002"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"In the process of scanning and parsing, the compiler checks to see that all of the program\u2019s tokens are well formed, and that the sequence of tokens conforms to the syntax defined by the context-free grammar. Any malformed tokens (e.g., 123abc or $@foo in C) should cause the scanner to produce an error message. Any syntactically invalid token sequence (e.g., A = X Y Z in C) should lead to an error message from the parser."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\u5728\u626b\u63cf\u548c\u89e3\u6790\u7684\u8fc7\u7a0b\u4e2d\uff0c\u7f16\u8bd1\u5668\u68c0\u67e5\u7a0b\u5e8f\u7684\u6240\u6709\u6807\u8bb0\u662f\u5426\u683c\u5f0f\u826f\u597d\uff0c\u5e76\u4e14\u6807\u8bb0\u5e8f\u5217\u662f\u5426\u7b26\u5408\u4e0a\u4e0b\u6587\u65e0\u5173\u8bed\u6cd5\u5b9a\u4e49\u7684\u8bed\u6cd5\u3002\u4efb\u4f55\u683c\u5f0f\u4e0d\u826f\u7684\u6807\u8bb0\uff08\u4f8b\u5982\uff0c\u5728C\u8bed\u8a00\u4e2d\u7684123abc\u6216$@foo\uff09\u90fd\u5e94\u8be5\u5bfc\u81f4\u626b\u63cf\u5668\u4ea7\u751f\u9519\u8bef\u6d88\u606f\u3002\u4efb\u4f55\u8bed\u6cd5\u4e0a\u65e0\u6548\u7684\u6807\u8bb0\u5e8f\u5217\uff08\u4f8b\u5982\uff0c\u5728C\u8bed\u8a00\u4e2d\u7684A = X Y Z\uff09\u5e94\u8be5\u5bfc\u81f4\u89e3\u6790\u5668\u4ea7\u751f\u9519\u8bef\u6d88\u606f\u3002"}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"semantic-analysis-and-intermediate-code-generation",children:"Semantic Analysis and Intermediate Code Generation"}),"\n",(0,a.jsx)(t.p,{children:"Semantic analysis is the discovery of meaning in a program. The semantic analysis phase of compilation recognizes when multiple occurrences of the same identifier are meant to refer to the same program entity,and ensures that the uses are consistent. In most languages the semantic analyzer tracks the types of both identifiers and expressions, both to verify consistent usage and to guide the generation of code in later phases."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\u8bed\u4e49\u5206\u6790\u662f\u5bf9\u7a0b\u5e8f\u4e2d\u542b\u4e49\u7684\u53d1\u73b0\u3002\u7f16\u8bd1\u7684\u8bed\u4e49\u5206\u6790\u9636\u6bb5\u8bc6\u522b\u4e86\u76f8\u540c\u6807\u8bc6\u7b26\u7684\u591a\u6b21\u51fa\u73b0\u610f\u5473\u7740\u5f15\u7528\u540c\u4e00\u7a0b\u5e8f\u5b9e\u4f53\uff0c\u5e76\u786e\u4fdd\u8fd9\u4e9b\u7528\u6cd5\u662f\u4e00\u81f4\u7684\u3002\u5728\u5927\u591a\u6570\u8bed\u8a00\u4e2d\uff0c\u8bed\u4e49\u5206\u6790\u5668\u8ddf\u8e2a\u6807\u8bc6\u7b26\u548c\u8868\u8fbe\u5f0f\u7684\u7c7b\u578b\uff0c\u65e2\u7528\u4e8e\u9a8c\u8bc1\u4e00\u81f4\u7684\u4f7f\u7528\uff0c\u4e5f\u7528\u4e8e\u6307\u5bfc\u540e\u7eed\u9636\u6bb5\u4ee3\u7801\u7684\u751f\u6210\u3002"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"To assist in its work,the semantic analyzer typically builds and maintains a symbol table data structure that maps each identifier to the information known about it. Among other things, this information includes the identifier\u2019s type, internal structure (if any), and scope (the portion of the program in which it is valid)."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\u4e3a\u4e86\u8f85\u52a9\u5176\u5de5\u4f5c\uff0c\u8bed\u4e49\u5206\u6790\u5668\u901a\u5e38\u6784\u5efa\u5e76\u7ef4\u62a4\u4e00\u4e2a\u7b26\u53f7\u8868\u6570\u636e\u7ed3\u6784\uff0c\u5c06\u6bcf\u4e2a\u6807\u8bc6\u7b26\u6620\u5c04\u5230\u5df2\u77e5\u7684\u4fe1\u606f\u3002\u8fd9\u4e9b\u4fe1\u606f\u5305\u62ec\u6807\u8bc6\u7b26\u7684\u7c7b\u578b\u3001\u5185\u90e8\u7ed3\u6784\uff08\u5982\u679c\u6709\u7684\u8bdd\uff09\u4ee5\u53ca\u4f5c\u7528\u57df\uff08\u5176\u6709\u6548\u7684\u7a0b\u5e8f\u90e8\u5206\uff09\u3002"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Using the symbol table, the semantic analyzer enforces a large variety of rules that are not captured by the hierarchical structure of the context-free grammar and the parse tree. In C, for example, it checks to make sure that"}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\u5229\u7528\u7b26\u53f7\u8868\uff0c\u8bed\u4e49\u5206\u6790\u5668\u5f3a\u5236\u6267\u884c\u8bb8\u591a\u4e0a\u4e0b\u6587\u65e0\u5173\u8bed\u6cd5\u548c\u89e3\u6790\u6811\u6240\u4e0d\u80fd\u6355\u83b7\u7684\u89c4\u5219\u3002\u4f8b\u5982\uff0c\u5728C\u8bed\u8a00\u4e2d\uff0c\u5b83\u4f1a\u68c0\u67e5\u786e\u4fdd"}),"\n"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Every identifier is declared before it is used."}),"\n",(0,a.jsx)(t.li,{children:"No identifier is used in an inappropriate context (calling an integer as a subroutine, adding a string to an integer, referencing a field of the wrong type of struct, etc.)."}),"\n",(0,a.jsx)(t.li,{children:"Subroutine calls provide the correct number and types of arguments."}),"\n",(0,a.jsx)(t.li,{children:"Labels on the arms of a switch statement are distinct constants."}),"\n",(0,a.jsx)(t.li,{children:"Any function with a non-void return type returns a value explicitly."}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"In many compilers, the work of the semantic analyzer takes the form of semantic action routines,invoked by the parser when it realizes that it has reached a particular point within a grammar rule."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\u5728\u8bb8\u591a\u7f16\u8bd1\u5668\u4e2d\uff0c\u8bed\u4e49\u5206\u6790\u5668\u7684\u5de5\u4f5c\u4ee5\u8bed\u4e49\u52a8\u4f5c\u4f8b\u7a0b\u7684\u5f62\u5f0f\u8fdb\u884c\uff0c\u5f53\u89e3\u6790\u5668\u610f\u8bc6\u5230\u5df2\u7ecf\u5230\u8fbe\u8bed\u6cd5\u89c4\u5219\u4e2d\u7684\u7279\u5b9a\u70b9\u65f6\uff0c\u4f1a\u8c03\u7528\u8fd9\u4e9b\u4f8b\u7a0b\u3002"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Of course, not all semantic rules can be checked at compile time. Those that can are referred to as the static semantics of the language. Those that must be checked at run time are referred to as the dynamic semantics of the language. C has very little in the way of dynamic checks (its designers opted for performance over safety). Examples of rules that other languages enforce at run time include the following."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\u5f53\u7136\uff0c\u5e76\u975e\u6240\u6709\u7684\u8bed\u4e49\u89c4\u5219\u90fd\u80fd\u5728\u7f16\u8bd1\u65f6\u8fdb\u884c\u68c0\u67e5\u3002\u90a3\u4e9b\u53ef\u4ee5\u5728\u7f16\u8bd1\u65f6\u68c0\u67e5\u7684\u89c4\u5219\u88ab\u79f0\u4e3a\u8bed\u8a00\u7684\u9759\u6001\u8bed\u4e49\u3002\u90a3\u4e9b\u5fc5\u987b\u5728\u8fd0\u884c\u65f6\u68c0\u67e5\u7684\u89c4\u5219\u88ab\u79f0\u4e3a\u8bed\u8a00\u7684\u52a8\u6001\u8bed\u4e49\u3002C\u8bed\u8a00\u5728\u52a8\u6001\u68c0\u67e5\u65b9\u9762\u51e0\u4e4e\u6ca1\u6709\u4ec0\u4e48\uff08\u5176\u8bbe\u8ba1\u8005\u9009\u62e9\u4e86\u6027\u80fd\u800c\u4e0d\u662f\u5b89\u5168\u6027\uff09\u3002\u5176\u4ed6\u8bed\u8a00\u5728\u8fd0\u884c\u65f6\u6267\u884c\u7684\u89c4\u5219\u7684\u4f8b\u5b50\u5305\u62ec\u4ee5\u4e0b\u5185\u5bb9\u3002"}),"\n"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Variables are never used in an expression unless they have been given a value."}),"\n",(0,a.jsx)(t.li,{children:"Pointers are never dereferenced unless they refer to a valid object."}),"\n",(0,a.jsx)(t.li,{children:"Array subscript expressions lie within the bounds of the array."}),"\n",(0,a.jsx)(t.li,{children:"Arithmetic operations do not overflow."}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"When it cannot enforce rules statically, a compiler will often produce code to perform appropriate checks at run time, aborting the program or generating an exception if one of the checks then fails. (Exceptions will be discussed in Section 8.5.) Some rules, unfortunately, may be unacceptably expensive or impossible to enforce, and the language implementation may simply fail to check them. In Ada, a program that breaks such a rule is said to be erroneous; in C its behavior is said to be undefined."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\u5f53\u7f16\u8bd1\u5668\u65e0\u6cd5\u9759\u6001\u5730\u5f3a\u5236\u6267\u884c\u89c4\u5219\u65f6\uff0c\u901a\u5e38\u4f1a\u751f\u6210\u4ee3\u7801\uff0c\u5728\u8fd0\u884c\u65f6\u6267\u884c\u9002\u5f53\u7684\u68c0\u67e5\uff0c\u5982\u679c\u5176\u4e2d\u4e00\u4e2a\u68c0\u67e5\u5931\u8d25\uff0c\u5219\u4e2d\u6b62\u7a0b\u5e8f\u6216\u751f\u6210\u5f02\u5e38\uff08\u5f02\u5e38\u5c06\u5728\u7b2c8.5\u8282\u4e2d\u8ba8\u8bba\uff09\u3002\u9057\u61be\u7684\u662f\uff0c\u4e00\u4e9b\u89c4\u5219\u53ef\u80fd\u6210\u672c\u8fc7\u9ad8\u6216\u65e0\u6cd5\u5b9e\u65bd\uff0c\u8bed\u8a00\u5b9e\u73b0\u53ef\u80fd\u4f1a\u7b80\u5355\u5730\u4e0d\u5bf9\u5176\u8fdb\u884c\u68c0\u67e5\u3002\u5728Ada\u4e2d\uff0c\u8fdd\u53cd\u6b64\u7c7b\u89c4\u5219\u7684\u7a0b\u5e8f\u88ab\u79f0\u4e3a\u9519\u8bef\u7684\uff1b\u5728C\u4e2d\uff0c\u5176\u884c\u4e3a\u88ab\u79f0\u4e3a\u672a\u5b9a\u4e49\u3002"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"A parse tree is sometimes known as a concrete syntax tree, because it demonstrates, completely and concretely, how a particular sequence of tokens can be derived under the rules of the context-free grammar. Once we know that a token sequence is valid, however, much of the information in the parse tree is irrelevant to further phases of compilation. In the process of checking static semantic rules, the semantic analyzer typically transforms the parse tree into an abstract syntax tree (otherwise known as an AST,or simply a syntax tree) by removing most of the \u201cartificial\u201d nodes in the tree\u2019s interior. The semantic analyzer also annotates the remaining nodes with useful information,such as pointers from identifiers to their symbol table entries. The annotations attached to a particular node are known as its attributes. A syntax tree for our GCD program is shown in Figure 1.5."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\u89e3\u6790\u6811\u6709\u65f6\u88ab\u79f0\u4e3a\u5177\u4f53\u8bed\u6cd5\u6811\uff0c\u56e0\u4e3a\u5b83\u5b8c\u5168\u800c\u5177\u4f53\u5730\u5c55\u793a\u4e86\u5728\u4e0a\u4e0b\u6587\u65e0\u5173\u6587\u6cd5\u89c4\u5219\u4e0b\u7279\u5b9a\u6807\u8bb0\u5e8f\u5217\u7684\u63a8\u5bfc\u8fc7\u7a0b\u3002\u7136\u800c\uff0c\u4e00\u65e6\u6211\u4eec\u77e5\u9053\u4e00\u4e2a\u6807\u8bb0\u5e8f\u5217\u662f\u6709\u6548\u7684\uff0c\u89e3\u6790\u6811\u4e2d\u7684\u5927\u90e8\u5206\u4fe1\u606f\u5bf9\u4e8e\u7f16\u8bd1\u7684\u540e\u7eed\u9636\u6bb5\u6765\u8bf4\u5c31\u53d8\u5f97\u65e0\u5173\u7d27\u8981\u4e86\u3002\u5728\u68c0\u67e5\u9759\u6001\u8bed\u4e49\u89c4\u5219\u7684\u8fc7\u7a0b\u4e2d\uff0c\u8bed\u4e49\u5206\u6790\u5668\u901a\u5e38\u4f1a\u901a\u8fc7\u79fb\u9664\u6811\u4e2d\u5927\u90e8\u5206\u201c\u4eba\u4e3a\u201d\u8282\u70b9\uff0c\u5c06\u89e3\u6790\u6811\u8f6c\u6362\u6210\u62bd\u8c61\u8bed\u6cd5\u6811\uff08\u53c8\u79f0AST\uff0c\u6216\u8005\u7b80\u79f0\u8bed\u6cd5\u6811\uff09\u3002\u8bed\u4e49\u5206\u6790\u5668\u8fd8\u4f1a\u4e3a\u5269\u4f59\u7684\u8282\u70b9\u6dfb\u52a0\u6709\u7528\u7684\u4fe1\u606f\uff0c\u6bd4\u5982\u4ece\u6807\u8bc6\u7b26\u5230\u5b83\u4eec\u7684\u7b26\u53f7\u8868\u6761\u76ee\u7684\u6307\u9488\u3002\u9644\u52a0\u5230\u7279\u5b9a\u8282\u70b9\u7684\u6ce8\u91ca\u88ab\u79f0\u4e3a\u5b83\u7684\u5c5e\u6027\u3002\u6211\u4eec\u7684\u6700\u5927\u516c\u7ea6\u6570\u7a0b\u5e8f\u7684\u8bed\u6cd5\u6811\u5982\u56fe1.5\u6240\u793a\u3002"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"In many compilers,the annotated syntax tree constitutes the intermediate form that is passed from the front end to the back end. In other compilers, semantic analysis ends with a traversal of the tree that generates some other intermediate form. One common such form consists of a control flow graph whose nodes resemble fragments of assembly language for a simple idealized machine. We will consider this option further in Chapter 14, where a control flow graph for our GCD program appears in Figure 14.3. In a suite of related compilers, the front ends for several languages and the back ends for several machines would share a common intermediate form."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\u5728\u8bb8\u591a\u7f16\u8bd1\u5668\u4e2d\uff0c\u5e26\u6ce8\u91ca\u7684\u8bed\u6cd5\u6811\u6784\u6210\u4e86\u4ece\u524d\u7aef\u4f20\u9012\u5230\u540e\u7aef\u7684\u4e2d\u95f4\u5f62\u5f0f\u3002\u5728\u5176\u4ed6\u7f16\u8bd1\u5668\u4e2d\uff0c\u8bed\u4e49\u5206\u6790\u4ee5\u904d\u5386\u751f\u6210\u67d0\u4e9b\u5176\u4ed6\u4e2d\u95f4\u5f62\u5f0f\u7684\u6811\u800c\u7ed3\u675f\u3002\u4e00\u79cd\u5e38\u89c1\u7684\u8fd9\u79cd\u5f62\u5f0f\u5305\u62ec\u4e00\u4e2a\u63a7\u5236\u6d41\u56fe\uff0c\u5176\u8282\u70b9\u7c7b\u4f3c\u4e8e\u7b80\u5316\u7406\u60f3\u673a\u5668\u7684\u6c47\u7f16\u8bed\u8a00\u7247\u6bb5\u3002\u6211\u4eec\u5c06\u5728\u7b2c14\u7ae0\u8fdb\u4e00\u6b65\u63a2\u8ba8\u8fd9\u4e2a\u9009\u9879\uff0c\u5728\u90a3\u91cc\u6211\u4eec\u7684GCD\u7a0b\u5e8f\u7684\u63a7\u5236\u6d41\u56fe\u51fa\u73b0\u5728\u56fe14.3\u4e2d\u3002\u5728\u4e00\u5957\u76f8\u5173\u7684\u7f16\u8bd1\u5668\u4e2d\uff0c\u591a\u79cd\u8bed\u8a00\u7684\u524d\u7aef\u548c\u591a\u79cd\u673a\u5668\u7684\u540e\u7aef\u5c06\u5171\u4eab\u4e00\u4e2a\u901a\u7528\u7684\u4e2d\u95f4\u5f62\u5f0f\u3002"}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"target-code-generation",children:"Target Code Generation"}),"\n",(0,a.jsx)(t.p,{children:"The code generation phase of a compiler translates the intermediate form into the target language. Given the information contained in the syntax tree, generating correct code is usually not a difficult task (generating good code is harder, as we shall see in Section 1.6.4). To generate assembly or machine language, the code generator traverses the symbol table to assign locations to variables, and then traverses the intermediate representation of the program, generating loads and stores for variable references,interspersed with appropriate arithmetic operations, tests, and branches. Naive code for our GCD example appears in Figure 1.6, in x86 assembly language. It was generated automatically by a simple pedagogical compiler."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\u7f16\u8bd1\u5668\u7684\u4ee3\u7801\u751f\u6210\u9636\u6bb5\u5c06\u4e2d\u95f4\u5f62\u5f0f\u8f6c\u6362\u4e3a\u76ee\u6807\u8bed\u8a00\u3002\u6839\u636e\u8bed\u6cd5\u6811\u4e2d\u5305\u542b\u7684\u4fe1\u606f\uff0c\u751f\u6210\u6b63\u786e\u7684\u4ee3\u7801\u901a\u5e38\u5e76\u4e0d\u662f\u4e00\u9879\u56f0\u96be\u7684\u4efb\u52a1\uff08\u751f\u6210\u4f18\u79c0\u7684\u4ee3\u7801\u66f4\u96be\uff0c\u6b63\u5982\u6211\u4eec\u5c06\u57281.6.4\u8282\u4e2d\u770b\u5230\u7684\u90a3\u6837\uff09\u3002\u4e3a\u4e86\u751f\u6210\u6c47\u7f16\u6216\u673a\u5668\u8bed\u8a00\uff0c\u4ee3\u7801\u751f\u6210\u5668\u904d\u5386\u7b26\u53f7\u8868\u4ee5\u4e3a\u53d8\u91cf\u5206\u914d\u4f4d\u7f6e\uff0c\u7136\u540e\u904d\u5386\u7a0b\u5e8f\u7684\u4e2d\u95f4\u8868\u793a\uff0c\u751f\u6210\u53d8\u91cf\u5f15\u7528\u7684\u52a0\u8f7d\u548c\u5b58\u50a8\uff0c\u5e76\u7a7f\u63d2\u9002\u5f53\u7684\u7b97\u672f\u64cd\u4f5c\u3001\u6d4b\u8bd5\u548c\u8df3\u8f6c\u3002\u6211\u4eec\u7684GCD\u793a\u4f8b\u7684\u6734\u7d20\u4ee3\u7801\u51fa\u73b0\u5728\u56fe1.6\u4e2d\uff0c\u4f7f\u7528x86\u6c47\u7f16\u8bed\u8a00\u7f16\u5199\u3002\u8fd9\u662f\u7531\u4e00\u4e2a\u7b80\u5355\u7684\u6559\u5b66\u7f16\u8bd1\u5668\u81ea\u52a8\u751f\u6210\u7684\u3002"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"The assembly language mnemonics may appear a bit cryptic,but the comments on each line (not generated by the compiler!) should make the correspondence between Figures 1.5 and 1.6 generally apparent. A few hints: esp, ebp, eax, ebx, and edi are registers (special storage locations, limited in number, that can be accessed very quickly). -8(%ebp) refers to the memory location 8 bytes before the location whose address is in register ebp; in this program, ebp serves as a base from which we can find variables i and j. The argument to a subroutine call instruction is passed by pushing it onto a stack, for which esp is the top-of-stack pointer. The return value comes back in register eax. Arithmetic operations overwrite their second argument with the result of the operation."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\u8fd9\u4e9b\u6c47\u7f16\u8bed\u8a00\u52a9\u8bb0\u7b26\u53ef\u80fd\u770b\u8d77\u6765\u6709\u70b9\u6666\u6da9\uff0c\u4f46\u6bcf\u884c\u7684\u6ce8\u91ca\uff08\u5e76\u975e\u7531\u7f16\u8bd1\u5668\u751f\u6210\uff01\uff09\u5e94\u8be5\u80fd\u591f\u4f7f\u56fe1.5\u548c\u56fe1.6\u4e4b\u95f4\u7684\u5bf9\u5e94\u5173\u7cfb\u57fa\u672c\u4e0a\u663e\u800c\u6613\u89c1\u3002\u4e00\u4e9b\u63d0\u793a\uff1aesp\u3001ebp\u3001eax\u3001ebx\u548cedi\u662f\u5bc4\u5b58\u5668\uff08\u7279\u6b8a\u7684\u5b58\u50a8\u4f4d\u7f6e\uff0c\u6570\u91cf\u6709\u9650\uff0c\u53ef\u4ee5\u88ab\u975e\u5e38\u5feb\u901f\u5730\u8bbf\u95ee\uff09\u3002-8(%ebp)\u6307\u7684\u662f\u5728\u5bc4\u5b58\u5668ebp\u4e2d\u5b58\u50a8\u5730\u5740\u7684\u4f4d\u7f6e\u7684\u524d8\u4e2a\u5b57\u8282\u7684\u5185\u5b58\u4f4d\u7f6e\uff1b\u5728\u8fd9\u4e2a\u7a0b\u5e8f\u4e2d\uff0cebp\u7528\u4f5c\u57fa\u5740\uff0c\u6211\u4eec\u53ef\u4ee5\u4ece\u4e2d\u627e\u5230\u53d8\u91cfi\u548cj\u3002\u5bf9\u4e8e\u5b50\u7a0b\u5e8f\u8c03\u7528\u6307\u4ee4\uff0c\u53c2\u6570\u662f\u901a\u8fc7\u5c06\u5176\u63a8\u9001\u5230\u5806\u6808\u4e2d\u4f20\u9012\u7684\uff0cesp\u662f\u5806\u6808\u9876\u90e8\u6307\u9488\u3002\u8fd4\u56de\u503c\u5b58\u653e\u5728\u5bc4\u5b58\u5668eax\u4e2d\u3002\u7b97\u672f\u64cd\u4f5c\u4f1a\u7528\u64cd\u4f5c\u7684\u7ed3\u679c\u8986\u76d6\u5176\u7b2c\u4e8c\u4e2a\u53c2\u6570\u3002"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Often a code generator will save the symbol table for later use by a symbolic debugger, by including it in a nonexecutable part of the target code."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\u901a\u5e38\uff0c\u4ee3\u7801\u751f\u6210\u5668\u4f1a\u5c06\u7b26\u53f7\u8868\u4fdd\u5b58\u4e0b\u6765\uff0c\u4ee5\u4fbf\u5c06\u6765\u88ab\u7b26\u53f7\u8c03\u8bd5\u5668\u4f7f\u7528\uff0c\u65b9\u6cd5\u662f\u5c06\u5176\u5305\u542b\u5728\u76ee\u6807\u4ee3\u7801\u7684\u4e0d\u53ef\u6267\u884c\u90e8\u5206\u4e2d\u3002"}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"code-improvement",children:"Code Improvement"}),"\n",(0,a.jsx)(t.p,{children:"Code improvement is often referred to as optimization, though it seldom makes anything optimal in any absolute sense. It is an optional phase of compilation whose goal is to transform a program into a new version that computes the same result more efficiently\u2014more quickly or using less memory, or both."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\u4ee3\u7801\u6539\u8fdb\u901a\u5e38\u88ab\u79f0\u4e3a\u4f18\u5316\uff0c\u5c3d\u7ba1\u5728\u4efb\u4f55\u7edd\u5bf9\u610f\u4e49\u4e0a\u5b83\u5f88\u5c11\u4f7f\u4efb\u4f55\u4e1c\u897f\u90fd\u53d8\u5f97\u6700\u4f73\u3002\u5b83\u662f\u7f16\u8bd1\u7684\u4e00\u4e2a\u53ef\u9009\u9636\u6bb5\uff0c\u5176\u76ee\u6807\u662f\u5c06\u7a0b\u5e8f\u8f6c\u6362\u4e3a\u4e00\u4e2a\u8ba1\u7b97\u76f8\u540c\u7ed3\u679c\u7684\u66f4\u9ad8\u6548\u7248\u672c\u2014\u2014\u66f4\u5feb\u6216\u8005\u4f7f\u7528\u66f4\u5c11\u7684\u5185\u5b58\uff0c\u6216\u8005\u4e24\u8005\u517c\u800c\u6709\u4e4b\u3002"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Some improvements are machine independent. These can be performed as transformations onthe intermediate form. Other improvements require an understanding of the target machine (or of whatever will execute the program in the target language). These must be performed as transformations on the target program. Thus code improvement often appears as two additional phases of compilation, one immediately after semantic analysis and intermediate code generation, the other immediately after target code generation."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\u6709\u4e9b\u6539\u8fdb\u662f\u4e0e\u673a\u5668\u65e0\u5173\u7684\u3002\u8fd9\u4e9b\u53ef\u4ee5\u4f5c\u4e3a\u5bf9\u4e2d\u95f4\u5f62\u5f0f\u7684\u8f6c\u6362\u6765\u6267\u884c\u3002\u5176\u4ed6\u6539\u8fdb\u9700\u8981\u5bf9\u76ee\u6807\u673a\u5668\uff08\u6216\u8005\u5728\u76ee\u6807\u8bed\u8a00\u4e2d\u6267\u884c\u7a0b\u5e8f\u7684\u4efb\u4f55\u5185\u5bb9\uff09\u7684\u7406\u89e3\u3002\u8fd9\u4e9b\u5fc5\u987b\u4f5c\u4e3a\u5bf9\u76ee\u6807\u7a0b\u5e8f\u7684\u8f6c\u6362\u6765\u6267\u884c\u3002\u56e0\u6b64\uff0c\u4ee3\u7801\u6539\u8fdb\u901a\u5e38\u51fa\u73b0\u4e3a\u7f16\u8bd1\u7684\u4e24\u4e2a\u989d\u5916\u9636\u6bb5\uff0c\u4e00\u4e2a\u7d27\u8ddf\u8bed\u4e49\u5206\u6790\u548c\u4e2d\u95f4\u4ee3\u7801\u751f\u6210\u4e4b\u540e\uff0c\u53e6\u4e00\u4e2a\u7d27\u8ddf\u76ee\u6807\u4ee3\u7801\u751f\u6210\u4e4b\u540e\u3002"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Applying a good code improver to the code in Figure 1.6 produces the code shown in Example 1.2 (page 5). Comparing the two programs, we can see that the improved version is quite a lot shorter. Conspicuously absent are most of the loads and stores. The machine-independent code improver is able to verify that i and j can be kept in registers throughout the execution of the main loop. (This would not have been the case if,for example,the loop contained a call to a subroutine that might reuse those registers, or that might try to modify i or j.) The machine specific code improver is then able to assign i and j to actual registers of the target machine. For modern microprocessor architectures, particularly those with so-called superscalar implementations (ones in which separate functional units can execute instructions simultaneously), compilers can usually generate better code than can human assembly language programmers."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\u5c06\u56fe1.6\u4e2d\u7684\u4ee3\u7801\u5e94\u7528\u4e8e\u826f\u597d\u7684\u4ee3\u7801\u6539\u8fdb\u5668\u4f1a\u4ea7\u751f\u793a\u4f8b1.2\uff08\u7b2c5\u9875\uff09\u4e2d\u6240\u793a\u7684\u4ee3\u7801\u3002\u6bd4\u8f83\u8fd9\u4e24\u4e2a\u7a0b\u5e8f\uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u6539\u8fdb\u540e\u7684\u7248\u672c\u8981\u77ed\u5f97\u591a\u3002\u660e\u663e\u7f3a\u5931\u7684\u662f\u5927\u90e8\u5206\u7684\u52a0\u8f7d\u548c\u5b58\u50a8\u64cd\u4f5c\u3002\u673a\u5668\u65e0\u5173\u7684\u4ee3\u7801\u6539\u8fdb\u5668\u80fd\u591f\u9a8c\u8bc1\u5728\u4e3b\u5faa\u73af\u7684\u6267\u884c\u8fc7\u7a0b\u4e2d\uff0ci\u548cj\u53ef\u4ee5\u4e00\u76f4\u4fdd\u6301\u5728\u5bc4\u5b58\u5668\u4e2d\u3002\uff08\u5982\u679c\uff0c\u4f8b\u5982\uff0c\u5faa\u73af\u4e2d\u5305\u542b\u5bf9\u5b50\u7a0b\u5e8f\u7684\u8c03\u7528\uff0c\u8be5\u5b50\u7a0b\u5e8f\u53ef\u80fd\u4f1a\u91cd\u7528\u8fd9\u4e9b\u5bc4\u5b58\u5668\uff0c\u6216\u8005\u53ef\u80fd\u8bd5\u56fe\u4fee\u6539i\u6216j\uff0c\u90a3\u4e48\u60c5\u51b5\u5c31\u4e0d\u540c\u4e86\u3002\uff09\u7136\u540e\uff0c\u7279\u5b9a\u4e8e\u673a\u5668\u7684\u4ee3\u7801\u6539\u8fdb\u5668\u80fd\u591f\u5c06i\u548cj\u5206\u914d\u7ed9\u76ee\u6807\u673a\u5668\u7684\u5b9e\u9645\u5bc4\u5b58\u5668\u3002\u5bf9\u4e8e\u73b0\u4ee3\u5fae\u5904\u7406\u5668\u67b6\u6784\uff0c\u7279\u522b\u662f\u90a3\u4e9b\u5177\u6709\u6240\u8c13\u7684\u8d85\u6807\u91cf\u5b9e\u73b0\uff08\u53ef\u4ee5\u540c\u65f6\u6267\u884c\u6307\u4ee4\u7684\u72ec\u7acb\u529f\u80fd\u5355\u5143\uff09\uff0c\u7f16\u8bd1\u5668\u901a\u5e38\u80fd\u591f\u751f\u6210\u6bd4\u4eba\u7c7b\u6c47\u7f16\u8bed\u8a00\u7a0b\u5e8f\u5458\u66f4\u597d\u7684\u4ee3\u7801\u3002"}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"summary-and-concluding-remarks",children:"Summary and Concluding Remarks"}),"\n",(0,a.jsx)(t.p,{children:"In this chapter we introduced the study of programming language design and implementation. We considered why there are so many languages, what makes them successful or unsuccessful, how they may be categorized for study, and what benefits the reader is likely to gain from that study. We noted that language design and language implementation are intimately related to one another. Obviously an implementation must conform to the rules of the language. At the same time, a language designer must consider how easy or difficult it will be to implement various features, and what sort of performance is likely to result for programs that use those features."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\u5728\u672c\u7ae0\u4e2d\uff0c\u6211\u4eec\u4ecb\u7ecd\u4e86\u7f16\u7a0b\u8bed\u8a00\u8bbe\u8ba1\u548c\u5b9e\u73b0\u7684\u7814\u7a76\u3002\u6211\u4eec\u8003\u8651\u4e86\u4e3a\u4ec0\u4e48\u4f1a\u6709\u8fd9\u4e48\u591a\u79cd\u8bed\u8a00\uff0c\u662f\u4ec0\u4e48\u8ba9\u5b83\u4eec\u6210\u529f\u6216\u5931\u8d25\uff0c\u5b83\u4eec\u53ef\u4ee5\u5982\u4f55\u5206\u7c7b\u8fdb\u884c\u7814\u7a76\uff0c\u4ee5\u53ca\u8bfb\u8005\u53ef\u80fd\u4ece\u8fd9\u4e9b\u7814\u7a76\u4e2d\u83b7\u5f97\u4ec0\u4e48\u597d\u5904\u3002\u6211\u4eec\u6307\u51fa\u8bed\u8a00\u8bbe\u8ba1\u548c\u8bed\u8a00\u5b9e\u73b0\u4e4b\u95f4\u5bc6\u5207\u76f8\u5173\u3002\u663e\u7136\uff0c\u5b9e\u73b0\u5fc5\u987b\u7b26\u5408\u8bed\u8a00\u7684\u89c4\u5219\u3002\u540c\u65f6\uff0c\u8bed\u8a00\u8bbe\u8ba1\u8005\u5fc5\u987b\u8003\u8651\u5b9e\u73b0\u5404\u79cd\u7279\u6027\u7684\u96be\u6613\u7a0b\u5ea6\uff0c\u4ee5\u53ca\u4f7f\u7528\u8fd9\u4e9b\u7279\u6027\u7684\u7a0b\u5e8f\u53ef\u80fd\u4f1a\u4ea7\u751f\u600e\u6837\u7684\u6027\u80fd\u3002"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Language implementations are commonly differentiated into those based on interpretation and those based on compilation. We noted, however, that the difference between these approaches is fuzzy,and that most implementations include a bit of each. As a general rule, we say that a language is compiled if execution is preceded by a translation step that (1) fully analyzes both the structure (syntax) and meaning (semantics) of the program, and (2) produces an equivalent program in a significantly different form. The bulk of the implementation material in this book pertains to compilation."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\u7f16\u7a0b\u8bed\u8a00\u7684\u5b9e\u73b0\u901a\u5e38\u5206\u4e3a\u57fa\u4e8e\u89e3\u91ca\u548c\u57fa\u4e8e\u7f16\u8bd1\u7684\u4e24\u79cd\u7c7b\u578b\u3002\u7136\u800c\uff0c\u6211\u4eec\u6307\u51fa\u8fd9\u4e24\u79cd\u65b9\u6cd5\u4e4b\u95f4\u7684\u533a\u522b\u662f\u6a21\u7cca\u7684\uff0c\u5e76\u4e14\u5927\u591a\u6570\u5b9e\u73b0\u90fd\u5305\u542b\u4e86\u4e24\u8005\u7684\u4e00\u4e9b\u7279\u70b9\u3002\u4e00\u822c\u800c\u8a00\uff0c\u6211\u4eec\u8bf4\u4e00\u79cd\u8bed\u8a00\u662f\u7f16\u8bd1\u578b\u7684\uff0c\u5982\u679c\u5728\u6267\u884c\u4e4b\u524d\u9700\u8981\u7ecf\u8fc7\u4e00\u4e2a\u7ffb\u8bd1\u6b65\u9aa4\uff0c\u8fd9\u4e2a\u6b65\u9aa4\u4f1a\uff081\uff09\u5b8c\u5168\u5206\u6790\u7a0b\u5e8f\u7684\u7ed3\u6784\uff08\u8bed\u6cd5\uff09\u548c\u542b\u4e49\uff08\u8bed\u4e49\uff09\uff0c\u4ee5\u53ca\uff082\uff09\u751f\u6210\u4e00\u4e2a\u5728\u5f62\u5f0f\u4e0a\u660e\u663e\u4e0d\u540c\u7684\u7b49\u6548\u7a0b\u5e8f\u3002\u672c\u4e66\u4e2d\u5927\u90e8\u5206\u7684\u5b9e\u73b0\u5185\u5bb9\u6d89\u53ca\u7f16\u8bd1\u3002"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Compilers are generally structured as a series of phases. The first few phases scanning, parsing, and semantic analysis\u2014serve to analyze the source program. Collectively these phases are known as the compiler\u2019s front end. The final few phases\u2014intermediate code generation, code improvement, and target code generation\u2014are known as the back end. They serve to build a target program preferably a fast one\u2014whose semantics match those of the source."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\u7f16\u8bd1\u5668\u901a\u5e38\u88ab\u6784\u5efa\u4e3a\u4e00\u7cfb\u5217\u9636\u6bb5\u3002\u6700\u521d\u7684\u51e0\u4e2a\u9636\u6bb5\u2014\u2014\u626b\u63cf\u3001\u89e3\u6790\u548c\u8bed\u4e49\u5206\u6790\u2014\u2014\u7528\u4e8e\u5206\u6790\u6e90\u7a0b\u5e8f\u3002\u8fd9\u4e9b\u9636\u6bb5\u7edf\u79f0\u4e3a\u7f16\u8bd1\u5668\u7684\u524d\u7aef\u3002\u6700\u540e\u7684\u51e0\u4e2a\u9636\u6bb5\u2014\u2014\u4e2d\u95f4\u4ee3\u7801\u751f\u6210\u3001\u4ee3\u7801\u4f18\u5316\u548c\u76ee\u6807\u4ee3\u7801\u751f\u6210\u2014\u2014\u88ab\u79f0\u4e3a\u540e\u7aef\u3002\u5b83\u4eec\u7528\u4e8e\u6784\u5efa\u76ee\u6807\u7a0b\u5e8f\u2014\u2014\u6700\u597d\u662f\u4e00\u4e2a\u8bed\u4e49\u4e0e\u6e90\u7a0b\u5e8f\u76f8\u5339\u914d\u4e14\u5feb\u901f\u7684\u7a0b\u5e8f\u3002"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Chapters 3,6,7,8,and 9 form the core of the rest of this book. They cover fundamental issues of language design, both from the point of view of the programmer and from the point of view of the language implementor. To support the discussion of implementations, Chapters 2 and 4 describe compiler front ends in more detail than has been possible in this introduction. Chapter 5 provides an overview of assembly-level architecture. Chapters 14 through 16 discuss compiler back ends, including assemblers and linkers, run-time systems, and code improvement techniques. Additional language paradigms are covered in Chapters 10 through 13. Appendix A lists the principal programming languages mentioned in the text, together with a genealogical chart and bibliographic references. Appendix B contains a list of \u201cDesign & Implementation\u201d sidebars; Appendix C contains a list of numbered examples."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\u7b2c3\u30016\u30017\u30018\u548c9\u7ae0\u6784\u6210\u4e86\u672c\u4e66\u7684\u6838\u5fc3\u90e8\u5206\u3002\u5b83\u4eec\u6db5\u76d6\u4e86\u8bed\u8a00\u8bbe\u8ba1\u7684\u57fa\u672c\u95ee\u9898\uff0c\u65e2\u4ece\u7a0b\u5e8f\u5458\u7684\u89d2\u5ea6\uff0c\u4e5f\u4ece\u8bed\u8a00\u5b9e\u73b0\u8005\u7684\u89d2\u5ea6\u8fdb\u884c\u4e86\u8ba8\u8bba\u3002\u4e3a\u4e86\u652f\u6301\u5bf9\u5b9e\u73b0\u7684\u8ba8\u8bba\uff0c\u7b2c2\u7ae0\u548c\u7b2c4\u7ae0\u6bd4\u672c\u4ecb\u7ecd\u90e8\u5206\u66f4\u8be6\u7ec6\u5730\u63cf\u8ff0\u4e86\u7f16\u8bd1\u5668\u7684\u524d\u7aef\u3002\u7b2c5\u7ae0\u6982\u8ff0\u4e86\u6c47\u7f16\u7ea7\u67b6\u6784\u3002\u7b2c14\u81f316\u7ae0\u8ba8\u8bba\u4e86\u7f16\u8bd1\u5668\u7684\u540e\u7aef\uff0c\u5305\u62ec\u6c47\u7f16\u5668\u548c\u94fe\u63a5\u5668\u3001\u8fd0\u884c\u65f6\u7cfb\u7edf\u4ee5\u53ca\u4ee3\u7801\u4f18\u5316\u6280\u672f\u3002\u7b2c10\u81f313\u7ae0\u6db5\u76d6\u4e86\u989d\u5916\u7684\u8bed\u8a00\u8303\u5f0f\u3002\u9644\u5f55A\u5217\u51fa\u4e86\u6587\u672c\u4e2d\u63d0\u5230\u7684\u4e3b\u8981\u7f16\u7a0b\u8bed\u8a00\uff0c\u4ee5\u53ca\u5b83\u4eec\u7684\u8c31\u7cfb\u56fe\u548c\u53c2\u8003\u6587\u732e\u3002\u9644\u5f55B\u5305\u542b\u4e86\u201c\u8bbe\u8ba1\u4e0e\u5b9e\u73b0\u201d\u65b9\u5757\u7684\u5217\u8868\uff1b\u9644\u5f55C\u5305\u542b\u4e86\u7f16\u53f7\u793a\u4f8b\u7684\u5217\u8868\u3002"}),"\n"]})]})}function m(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>o,a:()=>r});var a=n(7294);const i={},s=a.createContext(i);function r(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);